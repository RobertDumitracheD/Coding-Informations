Design Principles & Arhitectural

System Design questions =========================================

What is a microservice arhitecture and what are the advantages and drawbacks?

- Microservice architecture is an approach to designing software systems as a collection of small, independent, loosely coupled services.
- Each microservice focuses on a specific business capability and can be developed, deployed, and scaled independently.
- Microservices communicate with each other via APIs, often over HTTP/REST, messaging queues, or gRPC.
- This contrasts with monolithic architecture where all components are tightly integrated into a single application.

Advantages of Microservice Architecture:

1. Scalability:
   - Each service can be scaled independently based on demand, improving resource utilization.

2. Flexibility in Technology:
   - Different microservices can be built using different programming languages or frameworks best suited to the task.

3. Faster Development and Deployment:
   - Teams can develop, test, and deploy services independently, speeding up release cycles.

4. Fault Isolation:
   - Failure in one microservice usually does not impact the entire system.

5. Easier Maintenance:
   - Smaller codebases are easier to understand, manage, and update.

Drawbacks of Microservice Architecture:

1. Complexity:
   - Managing many services increases operational complexity,monitoring, and debugging.

2. Distributed System Challenges:
   - Issues like network latency, message serialization, and eventual consistency must be handled.

3. Data Management:
   - Managing transactions and consistency across services can be difficult.

4. Increased Resource Use:
   - Each microservice runs in its own process, often requiring more memory and CPU than a monolith.

5. Testing and Debugging:
   - End-to-end testing is more complex due to multiple independent services interacting.


What is a load balancer? 
A load balancer is acting as a gate in front of our services that routes the request to the available node with least amount of load. 
Algorithms 
	Round-Robin 123 123 123 and repeat
	Geo-based assigned to each region an user is routed to that instance(low response time, 			drowbacks-> doesn't help with load balancing too much)
	Least connections (note down and nr of connections and connect to least connection 	machine)

What is a DNS?
It's a service that maps a domain name to an ip address

What is a Proxy?
A proxy is something that acts on behalf of something else—it stands in the middle between a client and a target (like a server, object, or service) to control, filter, modify, or observe communication.
Reverse Proxy	Sits in front of servers, routes incoming requests	Like a gatekeeper at a concert directing you to the right section

What is a middleware?
Middleware is a term commonly used in software development to describe a piece of code that sits between two layers of an application and helps manage the communication, data, or behavior between them.
🛠 Common Tasks Middleware Performs:

    Authentication (check if user is logged in)

    Authorization (check if user has permission)

    Logging (record details about requests)

    Data validation (check if input is valid)

    Error handling

    Response formatting

What is vertical Scaling ? Horizontal scalling?
vertical scaling -> bigger server
horizontal scaling -> multiple servers -> more fault tollerant, distribute the workload to multiple machines

How to scale the database?
Indexing -> is a way of going directly to the data needed, without searching in the entire table,
we should index only the most accessed columns because it slows down writing

Replication -> Primary replicas -> write to the other replicas -> each replica can be called by calls using load balancer -> what is used for?

Sharding -> divide database in multiple shards, data is distributed based on a sharding key, reducing load, improves write and read performance since data is loaded across multiple shards. HORIZONTAL PARTITIONING

VERTICAL PARTITIONING -> splitting a huge table into small tables to reduce unnecesary disk i/o, scanning only relevant columns

Denormalization -> reduces the number of joins by combining related data into a single table (used in read-heavy application)

Where you can store large files ? -> Blob storage like AWS S3, get's an unique url that can be used

What is a CDN?
Content delivery network -> a global network of distributed servers that work together to deliver content.

What is cdn cache?
A CDN cache refers to the content delivery network (CDN) storing copies of content—such as images, videos, stylesheets, scripts, or even entire web pages—closer to users to reduce latency and server load.
You run a website hosted in New York. A user in Tokyo visits your site.
	Without a CDN: The user in Tokyo loads the site directly from New York—slow and possibly inefficient.
	With a CDN: A CDN server in Japan already has a cached version of your site’s static content. The user accesses that local copy—much faster.Faster loading times,Reduced origin server load,Better scalability,Improved user experience globally
    
What is caching?
Storing frequently access data in memory
Cache aside patterns -> application looks for the cache if it has it retrieves directly, if not it calls the db. To prevent outDated value for being served use TTL

What are SOLID principles?
S – Single Responsibility Principle (SRP)
- A class should have only one reason to change.
- This means each class should focus on a single task or responsibility.
- Example: Don't mix business logic and logging in the same class.

O – Open/Closed Principle (OCP)
- Software entities (classes, modules, functions) should be open for extension but closed for modification.
- You should be able to add new functionality without changing existing code.
- Example: Use interfaces and abstract classes so new behavior can be added through inheritance.

L – Liskov Substitution Principle (LSP)
- Subtypes must be substitutable for their base types.
- If class B is a subclass of class A, it should behave in a way that doesn’t break the expectations of A.
- Example: You should be able to use a subclass wherever a superclass is expected without errors or unexpected behavior.

// Step 1: Create a common interface
interface PaymentMethod {
    fun process()
}

// Step 2: Implement each payment method
class CreditCardPayment : PaymentMethod {
    override fun process() = println("Processing credit card")
}

class PayPalPayment : PaymentMethod {
    override fun process() = println("Processing PayPal")
}

class CryptoPayment : PaymentMethod {
    override fun process() = println("Processing crypto")
}

// Step 3: Use polymorphism (extend, don't modify)
class PaymentProcessor {
    fun process(payment: PaymentMethod) {
        payment.process()
    }
}

I – Interface Segregation Principle (ISP)
- No client should be forced to depend on methods it does not use.
- Create specific interfaces instead of one large general-purpose interface.
- Example: Don’t create a `Bird` interface with `fly()` if some birds don’t fly (like penguins).

D – Dependency Inversion Principle (DIP)
- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.
- Example: Use interfaces or abstract classes so you can swap implementations without changing the higher-level logic.
interface MessageService {
    fun sendMessage(message: String)
}

// Low-level modules
class EmailService : MessageService {
    override fun sendMessage(message: String) {
        println("Sending email: $message")
    }
}

class SmsService : MessageService {
    override fun sendMessage(message: String) {
        println("Sending SMS: $message")
    }
}

// High-level module depends on abstraction
class NotificationManager(private val service: MessageService) {
    fun notify(message: String) {
        service.sendMessage(message)
    }
}


What are message queues?
Is a way of communicating asynchronously without blocking other operations,
Producer -> produces a message in a queue that temporaly holds the message and the consumer retrieves the message and process it.
More information?!

What are distributed messaging systems ? Apache kafka?
	A distributed messaging system is a software system designed to send and receive messages between different parts of a distributed system, reliably and at scale. These systems decouple producers (senders of data) from consumers (receivers of data), improving scalability, fault tolerance, and real-time data flow across services or applications.
	Log aggregation
	Real-time analytics
	Event-driven architecture
	Data pipelines
	IoT data streaming
	Microservices communication
	Apache Kafka is a high-throughput, distributed messaging system developed by LinkedIn and now part of the Apache Software 	Foundation. It's one of the most widely used messaging platforms today.

what is reliability and availability?
✅ Availability (Is it working now?)

    Definition: The percentage of time a system is operational and accessible when needed.
Reliability (Does it work correctly over time?)

    Definition: The system’s ability to consistently perform its intended function without failures over time.
    
what is the efficiency? Latency? Throughtput?
⚡ Efficiency

    Efficiency is how well a system uses resources (like CPU, memory, time, energy) to perform a task.
    
Latency is the time delay between a request and the corresponding response.
Types:
    Network latency: Time for data to travel across a network.
    Disk latency: Time to read/write to disk.
    Application latency: Time to respond to a user request.
 Throughput
    Throughput is the amount of work done or data processed per unit time.

    Usually measured in:
        Requests per second (RPS)
        Transactions per second (TPS)
        MB/s or GB/s (for data)    
        
What is APi GATEWAY?
It provides Authentication, rate limiting, logging, monitoring, request routing

What is Rate limiting?
Is adding restrictions of number requests per time unit, if the limit is exceeded servers blocks requests

What is Idempotency?
Multiple requests produce the same result. Each request has assigned a unique id. server checks if that id has already been handled before processing again a failed request

what is cloud? what is aws? what are the components of aws?
Cloud computing is the delivery of computing services—like servers, storage, databases, networking, software, and more—over the internet ("the cloud") rather than on local computers or servers.
EC2 (Elastic Compute Cloud) – Virtual servers in the cloud
Lambda – Serverless computing (run code without managing servers)
ECS / EKS – Containers (Docker) and Kubernetes orchestration
S3 (Simple Storage Service) – Object storage for files, backups, media
EBS (Elastic Block Store) – Disk storage for EC2
Glacier – Long-term archival storage
RDS – Managed relational databases (MySQL, PostgreSQL, etc.)
DynamoDB – NoSQL key-value store
Aurora – High-performance MySQL/PostgreSQL-compatible engine
VPC (Virtual Private Cloud) – Isolated network for your AWS resources
Route 53 – DNS and domain management
API Gateway – Manage and expose APIs securely
🔒 5. Security & Identity
    IAM (Identity and Access Management) – User and permission control
    KMS (Key Management Service) – Encryption key management
    Cognito – User sign-up/login and authentication
📈 6. Monitoring & Analytics
    CloudWatch – Logs, metrics, and alerts
    CloudTrail – Tracks user activity and API usage
    Athena – Query S3 data using SQL
    
what is a design pattern? what kind of patterns you know? where is it used?
A design pattern is a reusable, proven solution to a common software design problem.
A. Creational Patterns (object creation)

1. Singleton - Ensures a class has only one instance and provides a global point of access.
2. Factory Method - Creates objects without specifying the exact class.
3. Abstract Factory - Creates families of related or dependent objects.
4. Builder - Separates object construction from its representation.
5. Prototype - Creates new objects by copying existing ones.

B. Structural Patterns (object composition)

1. Adapter - Makes incompatible interfaces compatible.
2. Bridge - Separates an object’s abstraction from its implementation.
3. Composite - Treats groups of objects the same as individual ones.
4. Decorator - Dynamically adds behavior to objects.
5. Facade - Provides a simplified interface to a complex subsystem.
6. Proxy - Controls access to another object.
7. Flyweight - Minimizes memory usage by sharing data.

C. Behavioral Patterns (object interaction)

1. Observer - Notifies objects when a subject changes state.
2. Strategy - Selects algorithms at runtime.
3. Command - Encapsulates a request as an object.
4. Chain of Responsibility - Passes request along a chain of handlers.
5. Mediator - Centralizes communication between components.
6. Memento - Saves and restores object state without violating encapsulation.
7. State - Changes object behavior based on internal state.
8. Template Method - Defines a skeleton of an algorithm in a method.
9. Iterator - Provides sequential access to elements in a collection.
10. Visitor - Adds new operations to objects without changing them.

explain some projects that you worked on, what did you use?

What are SLO's and SLA's?

These are key terms used in service reliability and performance management, especially in cloud services and distributed systems.

--------------------------------------------------
1. SLA – Service Level Agreement
--------------------------------------------------

Definition:
An **SLA (Service Level Agreement)** is a formal, legally binding **contract** between a service provider and a customer that defines **expected service levels**.

Key Features:
- Defines specific metrics (e.g., uptime, response time)
- Specifies penalties for failure (e.g., service credits, refunds)
- Used in commercial relationships (e.g., AWS, Azure, etc.)

2. SLO – Service Level Objective
--------------------------------------------------

Definition:
An **SLO (Service Level Objective)** is a specific **internal target** or goal for a service's performance or reliability.

Key Features:
- Not a contract, but an **internal commitment**
- Used by engineers/SREs to guide system performance
- Helps measure whether a service is operating reliably

What is an anti-pattern?

Advanced knowledge questions =======================================================

What is HTTP/HTTPS ?
Is a protocol with the help that client communicates with servers (HTTPS uses TLS or SSL in such a way that even if the request is intercepted the atacker cannot access the request data). HTTP protocol doesn t define how request should be structured, what is the format of resonse or how client should interact with server.

What are APIS
Application programming interface is a set of rules that define how client and server needs to communicate-> API STYLES REST, GRAPHQL ,SOAP

What is REST?
REST is an architectural style for designing networked applications, particularly web services, that aims for simplicity, scalability, and statelessness. Systems that follow the REST paradigm are stateless, meaning that the server does not need to know anything about what state the client is in and vice versa. In this way, both the server and the client can understand any message received, even without seeing previous messages. This constraint of statelessness is enforced through the use of resources, rather than commands. Resources are the nouns of the Web - they describe any object, document, or thing that you may need to store or send to other services.
Uses JSON

What is SOAP?
Is a communication that is based on XML, highly used on payment services. complex and verbose
🔒 Security (WS-Security)	SOAP supports enterprise-grade message-level security, encryption, and signing — essential for transmitting sensitive financial data.
📜 Strict contracts (WSDL)	Payment services demand strict schemas. With WSDL, clients know exactly what structure to send and expect.

What is gRPC?
High performance, it uses binary encoding, favor for microservices communication, most used for communication server to server
gRPC uses Protocol Buffers (protobuf) instead of JSON or XML.

Protobuf is a compact, binary format, which means:

    Smaller payloads (less data to transfer)

    Faster serialization/deserialization

    Lower CPU and memory usage
Multiplexing: Multiple requests/responses in parallel over a single connection

Stream support: Real-time bidirectional communication (client and server can push data)

Header compression: Smaller metadata = faster transmission

HTTP Verbs

There are 4 basic HTTP verbs we use in requests to interact with resources in a REST system:

    GET — retrieve a specific resource (by id) or a collection of resources
    POST — create a new resource
    PUT — update a specific resource (by id)
    DELETE — remove a specific resource by id

What is GRAPHQL?
Different than REST it returns only data that is needed, can get the data from multiple endpoints but requires more computing power.

What are Websockets?
continuuous 2 way communication, server can call also notify the client. Used for real time communication 

What is a database?
Is a server that ensure data storage, retrievaal and efficient management while keeping it secure, consistent and durable
 
WebHooks ? 
A server can send an http request to another server when an event occurs

What is relational database ?
Ex sql -> Predefined schema, respects ACID(
    ATOMICITY->commit all or nothing,
 CONSISTENCY-> stops invalid data from messing up the db (respects the constraints),
  ISOLATION -> concurrent transactions are isolated from each other, 
 DURABILITY-> data is persisted after transaction is commited even in system failure) proerpties, strong consistency, structured relationships
 When multiple threads (or users/processes) try to modify the same data in a SQL database, you can run into concurrency issues, such as:
 Lost updates
Pesimistic locking -> locking the row
Optimistic locking -> check before commit
    @Version
    var version: Long = 0
    
 1. READ_UNCOMMITTED

    🔸 Allows dirty reads (reading data that another transaction has written but not yet committed).

    ✅ Fast, but ❌ unsafe.

    Use case: Rare—used only for performance on non-critical reads.

2. READ_COMMITTED (✅ Default in many RDBMS like PostgreSQL)

    ❌ Prevents dirty reads.

    ✅ A transaction only sees committed changes from others.

    ❌ But allows non-repeatable reads (reading same row twice and getting different data).

    Use case: Basic consistency without too much locking.

3. REPEATABLE_READ

    ✅ Prevents dirty and non-repeatable reads.

    ❌ Allows phantom reads (re-running a query might return more rows).

    Uses row-level locks on read.

    Use case: Critical reads across multiple operations.

4. SERIALIZABLE

    ✅ Prevents all issues: dirty, non-repeatable, and phantom reads.

    Most strict and slowest.

    Acts like each transaction runs one after another.

    Use case: Financial operations or critical data workflows.
NonRelational
NOSQL -> high scalability, performance, flexible schema

Which and when to use? 
If needed relational data, strong consistency go for SQL
Banking system	Wells Fargo’s account DB	Need ACID transactions to ensure accurate balances and transfers.
E-commerce backend	Amazon's order & inventory system	Orders, products, customers, and invoices have strict relationships and constraints.
Hospital records	Electronic Health Records (EHR)	Patient data must be consistent and reliable with relational links (e.g., diagnoses, meds).
Flight booking systems	Airline reservation platforms (e.g. Delta, Lufthansa)	
High scalability + flexible schema -> NOSQL
Social media app	Instagram, TikTok user feed
Real-time analytics	Uber's ride data tracking


Basic Knowledge questions ==========================================================

Overloading?
Overloading is when multiple methods in the same class have the same name but different parameters (different type, number, or order).

Key points:
- Happens within the same class.
- Method name is the same but parameter lists differ.
- Return type can be the same or different.
- Used to increase the readability of the program.

Overrinding ?
Overriding is when a subclass provides a specific implementation for a method that is already defined in its superclass.

Key points:
- Happens between superclass and subclass.
- Method name, return type, and parameters must be the same.
- Enables runtime polymorphism (dynamic method dispatch).
- Allows a subclass to modify behavior of the superclass method.

1. What is method overloading? How is it different from method overriding?

Method overloading is defining multiple methods in the same class with the same name but different parameter lists (different type, number, or order of parameters). It is resolved at compile time (compile-time polymorphism).

Method overriding is when a subclass provides a specific implementation of a method that is already defined in its superclass, with the same method signature. It is resolved at runtime (runtime polymorphism).

Key difference:
- Overloading: same class, different parameters.
- Overriding: subclass modifies superclass method, same parameters.


What is polymorphism? 

1. What is polymorphism, and why is it useful?
 It allows objects of different classes to be treated as objects of a common super class. It enables a single function, method, or operator to work in different ways based on the object it is acting upon.
Answer:
Polymorphism allows objects of different classes to be treated through a common interface, enabling flexible and scalable code. It promotes loose coupling and code reuse.
2. What's the difference between method overloading and overriding?

Answer:

    Overloading: Same method name, different parameters (compile-time polymorphism).

    Overriding: Subclass changes behavior of superclass method (run-time polymorphism).

3. How does polymorphism improve extensibility?

Answer:
You can add new types (e.g., a PushNotifier) without changing the code that uses the Notifier interface. This follows the Open/Closed Principle – open for extension, closed for modification.

---

2. Can constructors be overloaded? Can they be overridden?

Constructors can be overloaded by defining multiple constructors with different parameter lists in the same class.

Constructors cannot be overridden because they are not inherited by subclasses.

---

3. What are the benefits of method overriding?

- Allows runtime polymorphism, enabling dynamic method dispatch.
- Enables a subclass to provide a specific behavior different from the superclass.
- Supports extensibility and flexibility in code.
- Helps implement interfaces and abstract classes.
- Improves code reusability and maintainability.

---

4. What is compile-time polymorphism? What is runtime polymorphism?

Compile-time polymorphism is method overloading and operator overloading where the method to invoke is determined during compilation.

Runtime polymorphism is method overriding where the method to invoke is determined during program execution (runtime), depending on the object type.

---

5. Can you override a static method? Why or why not?

No, static methods cannot be overridden because they belong to the class, not instances. If you declare a static method with the same signature in a subclass, it hides the superclass method (method hiding), not overrides it.

---

6. What happens if the return type differs in overriding?

In overriding, the return type must be the same or a subtype (covariant return type) of the return type in the superclass method.

If the return types are incompatible, the code will not compile.

---

7. Can private methods be overridden?

No, private methods cannot be overridden because they are not visible to subclasses (they are class-private). If a subclass declares a method with the same signature, it is treated as a new method (method hiding), not overriding.



Interface ?

An interface is a programming construct that defines a **contract** in the form of method signatures without implementing them. It specifies **what methods a class must implement**, but not how.

Common Interview Questions and Answers about Interfaces:

1. What is the difference between an abstract class and an interface?

- Abstract class can have both abstract and concrete methods; interfaces mostly have abstract methods (except default and static methods in Java 8+).
- A class can implement multiple interfaces but can extend only one abstract class.
- Abstract classes can have constructors and maintain state (fields); interfaces usually cannot (though they can have constants).

2. Can interfaces have fields or variables?

- Interfaces can have constants (static final fields), but cannot have instance variables.
- All fields in interfaces are implicitly public, static, and final.

3. Can you instantiate an interface?

- No, you cannot instantiate an interface directly because it contains abstract methods without implementation.

4. What is multiple inheritance in terms of interfaces?

- Since many languages (like Java) do not support multiple inheritance of classes, interfaces provide a way to achieve multiple inheritance of type.
- A class can implement multiple interfaces, inheriting behavior contracts from all.

5. Can interfaces have default methods?

- In Java 8 and above, interfaces can have default methods with a method body.
- This helps add new methods to interfaces without breaking existing implementations.

6. How are interfaces used in real-world applications?

- To define APIs and contracts between modules.
- To enable polymorphism and loose coupling.
- To implement callbacks, event listeners, and plug-in architectures.

7. What happens if a class implements two interfaces that have methods with the same signature?

- The class must provide one implementation that satisfies both interfaces.
- If interfaces have default methods with the same signature, the class must override and resolve the conflict.

Classes ?
A class is a blueprint or template for creating objects in object-oriented programming. It defines the data (fields or attributes) and behaviors (methods or functions) that the created objects (instances) will have.
 What is the difference between a class and an object?

- A class is a blueprint or template defining the properties and behaviors.
- An object is an instance of a class with actual values.

2. What is a constructor? Can a class have multiple constructors?

- A constructor is a special method used to initialize objects.
- Yes, a class can have multiple constructors with different parameter lists (constructor overloading).

3. What is the difference between instance variables and class variables?

- Instance variables belong to individual objects.
- Class variables (static variables) belong to the class and are shared among all instances.

4. What are access modifiers? Name some commonly used ones.

- Access modifiers control the visibility of class members.
- Common modifiers: public, private, protected, and default (package-private in Java).

5. What is encapsulation?

- Encapsulation is the practice of hiding internal data and requiring all interaction to be performed through methods.
- Achieved by using private fields and public getter/setter methods.

6. Can a class inherit from multiple classes?

- In most languages like Java, a class cannot inherit from multiple classes (no multiple inheritance).
- However, it can implement multiple interfaces.

7. What is the difference between method overloading and method overriding in the context of classes?

- Overloading: same class, same method name, different parameters.
- Overriding: subclass modifies a superclass method with the same signature.

8. What is a static method? How is it different from an instance method?

- Static methods belong to the class, not instances.
- They can be called without creating an object.
- Instance methods belong to objects and require an instance to be called.

Heap & stack memory?

Types of Memory: Heap and Stack

1. Stack Memory:

- The stack is a region of memory that stores **local variables, method/function call information (call frames/activation records), and control flow data**.
- It operates in a Last In, First Out (LIFO) manner.
- Memory allocation and deallocation are fast and automatic when methods are called and return.
- Each thread has its own stack.
- Variables stored: Primitive local variables, references to objects.
- Size is limited and usually smaller than heap.
- Example: When a method is invoked, its local variables and parameters are stored on the stack.

2. Heap Memory:

- The heap is a region of memory used for **dynamic memory allocation**, storing objects and data created at runtime.
- Memory allocation/deallocation is managed by the programmer or automatically via garbage collection (in languages like Java, C#).
- Shared across threads.
- Variables stored: Objects, arrays, and their instance variables.
- Typically larger than stack and slower to allocate.
- Objects created with `new` keyword (Java, C++) are stored here.

---

Summary Table:

| Memory Type | What is stored                  | Lifetime                     | Size         | Managed by       |
|-------------|--------------------------------|------------------------------|--------------|------------------|
| Stack       | Local variables, function calls | Until method returns          | Smaller      | Automatically    |
| Heap        | Objects, dynamic data            | Until garbage collected/free  | Larger       | Programmer/Garbage Collector |

---

Common Interview Questions and Answers:

1. What is the difference between stack and heap memory?

- Stack stores local variables and method call info, managed automatically in LIFO order.
- Heap stores objects and dynamic data, managed via garbage collection or manual memory management.

2. Which memory is faster to access, stack or heap?

- Stack memory is faster due to its LIFO nature and contiguous allocation.
- Heap memory is slower because of dynamic allocation and fragmentation.

3. What happens if stack memory is full?

- A StackOverflowError (in Java) or stack overflow occurs, usually due to deep or infinite recursion.

4. Can primitive data types be stored in heap memory?

- No, primitives declared as local variables are stored in stack.
- If primitives are part of objects, those objects live on the heap.

5. How is memory allocated in the heap?

- Memory is allocated dynamically when objects are created.
- Managed manually (C/C++) or by garbage collectors (Java, C#).

6. What is garbage collection?

- Automatic process that frees heap memory occupied by objects no longer referenced.

7. Does each thread have its own heap or stack?

- Each thread has its own stack.
- Heap is shared among all threads.

---

Exceptions Errors ? ? 

- An exception is an event that disrupts the normal flow of a program during execution.
- Exceptions represent conditions that a program might want to catch and handle to continue running.
- Example: 
  - `NullPointerException` (accessing a null reference)
  - `IOException` (failure in input/output operations)
- In Java, exceptions are subclasses of `java.lang.Exception`.
- In Kotlin, exceptions are also subclasses of `Throwable`, but there is no checked exception mechanism.

What is an Error?

- An error is a serious problem that a program generally cannot handle or recover from.
- Errors represent system-level issues such as JVM failures or hardware problems.
- Examples:
  - `OutOfMemoryError` (JVM runs out of memory)
  - `StackOverflowError` (too deep recursion)
- In Java and Kotlin, errors are subclasses of `java.lang.Error`.
- Errors are usually not caught by programs and should be allowed to propagate.

Difference Between Checked and Unchecked Exceptions

Checked Exceptions:
- Must be either caught in a try-catch block or declared in the method signature using `throws` (Java only).
- Represent recoverable conditions.
- Example: `IOException`, `SQLException`.
- In Kotlin, checked exceptions do not exist.

Unchecked Exceptions:
- Also called runtime exceptions.
- Do not require explicit handling or declaration.
- Usually indicate programming errors or logic mistakes.
- Subclasses of `RuntimeException` in Java.
- Examples: `NullPointerException`, `IllegalArgumentException`, `ArrayIndexOutOfBoundsException`.

Mutable Immutable classes
1. Mutable Classes:

- Objects whose state (fields/data) can be changed after creation.
- Fields can be modified via setters or direct access.
- Examples: Java’s `ArrayList`, Kotlin’s `MutableList`.
- Use cases: When you need to update object data frequently.
- Requires careful handling in multithreaded environments to avoid concurrency issues.
2. Immutable Classes:
- Objects whose state cannot be changed once created.
- No setters; all fields are final or read-only.
- Thread-safe by default because state can’t change.
- Examples: Java’s `String`, Kotlin’s `String` and `List` (by default).
- Benefits: Simplifies reasoning about code, safer in concurrency.
final class Person {
    private final String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

1. What is the difference between mutable and immutable objects?

- Mutable objects can have their state changed after creation; immutable objects cannot.

2. Why use immutable classes?

- They are inherently thread-safe.
- Easier to reason about and less error-prone.
- Useful in functional programming styles.

3. How do you make a class immutable in Java?

- Declare class as final (optional but recommended).
- Make all fields private and final.
- Do not provide setters.
- Initialize all fields via constructor.
- Ensure mutable fields are not exposed (defensive copies).

4. Can immutable objects contain mutable objects?

- If they do, make defensive copies to preserve immutability.
- Otherwise, immutability can be broken through those mutable objects.

5. How does Kotlin support immutability?

- Kotlin distinguishes between read-only (`List`) and mutable (`MutableList`) collections.
- Data classes with `val` properties are immutable by default.

Data structures?
- Data structures are ways of organizing and storing data so that it can be accessed and modified efficiently.
- Different data structures are suited for different kinds of applications, depending on the operations needed (e.g., search, insert, delete).
- Common data structures include arrays, linked lists, stacks, queues, trees, graphs, hash tables, etc.

Data Structures and How They Work Internally
what are the threadsafe data structures in kotlin/java?
1. Collections in java.util.concurrent package

    ConcurrentHashMap<K, V>
    A highly scalable, thread-safe implementation of a hash map. Unlike synchronized maps, it allows concurrent read and updates without locking the entire map.

    CopyOnWriteArrayList<E>
    A thread-safe variant of ArrayList. It creates a new copy of the underlying array on each write (add, remove), so reads don’t block. Great for scenarios with many reads and few writes.

    CopyOnWriteArraySet<E>
    Similar to CopyOnWriteArrayList, but for sets.

    ConcurrentLinkedQueue<E>
    A thread-safe, non-blocking FIFO queue based on linked nodes.

    ConcurrentSkipListMap<K, V> and ConcurrentSkipListSet<E>
    Thread-safe sorted map and set implementations.

1. Array:
- Fixed-size contiguous block of memory storing elements.
- Access by index is direct and fast (O(1)) because elements are placed sequentially.
- Insertion/deletion in middle requires shifting elements (O(n)).

2. ArrayList (Dynamic Array):
- Internally uses an array.
- When full, creates a new larger array and copies elements (amortized resizing).
- Allows dynamic resizing while providing fast random access (O(1)).
- Adding elements at the end is generally O(1), except when resizing occurs.

3. Linked List:
- Consists of nodes where each node stores data and a reference to the next node.
- No contiguous memory; nodes can be scattered in memory.
- Insertions and deletions are fast (O(1)) if node reference is known.
- Access by index requires traversal (O(n)).

4. Stack:
- Can be implemented using an array or linked list.
- Operates LIFO: elements are pushed/popped from the top.
- Operations are O(1).

5. Queue:
- Can be implemented using an array (circular buffer) or linked list.
- Operates FIFO: elements are added at the rear and removed from the front.
- Operations are O(1).

6. Tree (e.g., Binary Search Tree):
- Hierarchical nodes with parent-child relationships.
- Each node holds references to its children.
- Balanced trees keep height low, ensuring O(log n) search/insert/delete.
- Unbalanced trees degrade to linked list performance (O(n)).

7. Hash Table (HashMap):
- Uses a hash function to convert keys into array indices.
- Handles collisions using chaining (linked lists at buckets) or probing.
- Average operations (search/insert/delete) are O(1).
- Performance depends on hash function quality and load factor.

Set (HashSet)

    Description:
    Stores unique elements with no guaranteed order. Uses a hash table internally.

    Time Complexity:

        Add / Remove / Contains: O(1) average

        Worst case: O(n) (rare, depends on hash collisions)

    When to use:
    Use when you need fast lookups and don’t care about order of elements. Great for checking membership or removing duplicates quickly.

TreeSet

    Description:
    Stores unique elements in sorted order. Internally a self-balancing binary search tree (Red-Black tree).

    Time Complexity:

        Add / Remove / Contains: O(log n)

    When to use:
    Use when you need the elements sorted or want to perform range queries (like getting elements between two values). Good when order matters and you still need reasonably fast operations.
---

Common Interview Questions and Answers:

1. How does an ArrayList manage dynamic resizing?

- It maintains an internal array.
- When capacity is reached, it creates a new larger array (usually 1.5 to 2 times bigger) and copies elements.
- This resizing happens infrequently, so average insertion at end is O(1).

2. What is the main advantage of a linked list over an array?

- Efficient insertions and deletions at any position without shifting elements.
- But slower access by index because it requires traversal.

3. How does a hash table handle collisions?

- By using separate chaining (linked lists or trees in buckets).
- Or open addressing (linear/quadratic probing) to find another free slot.

4. What is the time complexity of accessing an element in an ArrayList?

- O(1), because of direct index access to the underlying array.

5. What is the difference between stack and queue?

- Stack is LIFO (last in, first out).
- Queue is FIFO (first in, first out).

6. Why is balancing important in binary search trees?

- To keep operations efficient (O(log n)).
- Unbalanced trees can degrade to linked list performance (O(n)).

---

Summary Table:

| Data Structure  | Internal Working                   | Access Time | Insert/Delete Time      |
|-----------------|----------------------------------|-------------|------------------------|
| Array           | Contiguous memory array           | O(1)        | O(n) (middle)          |
| ArrayList       | Dynamic array with resizing       | O(1)        | O(1) amortized at end  |
| Linked List     | Nodes with pointers               | O(n)        | O(1) (if node known)   |
| Stack           | Array or linked list (LIFO)       | O(1)        | O(1)                   |
| Queue           | Array (circular) or linked list (FIFO) | O(1)    | O(1)                   |
| Binary Search Tree | Nodes with left/right pointers  | O(log n) avg| O(log n) avg           |
| Hash Table      | Array + hashing + collision handling | O(1) avg | O(1) avg               |



primitive types vs reference types?
1. Primitive Types:

- Basic data types provided by the programming language.
- Represent simple values and are usually stored directly in memory (stack).
- Typically immutable and have fixed size.
- Examples in Java/Kotlin:
  - Java: int, boolean, byte, short, long, float, double, char
  - Kotlin: Int, Boolean, Byte, Short, Long, Float, Double, Char (all are objects but treated like primitives for performance)
- Operations on primitives are fast and low-level.
- Not created using classes or objects.

2. Custom Types:

- User-defined types created using classes, structs, or other constructs.
- Can encapsulate data and behavior (methods).
- Stored as objects in heap memory (in JVM languages).
- Can have fields, methods, constructors, inheritance, etc.
- Examples: Person class, Order class, TreeNode class.
- Allow modeling of complex data and behaviors.

what is typescript?

- TypeScript is a programming language developed by Microsoft.
- It is a superset of JavaScript, meaning all JavaScript code is valid TypeScript.
- Adds static typing to JavaScript, allowing variables and functions to have explicit types.
- Helps catch errors during development through compile-time type checking.
- Supports features like interfaces, enums, generics, and access modifiers.
- TypeScript code is compiled (transpiled) into plain JavaScript to run in browsers or Node.js.
- Improves code maintainability, tooling support (like autocompletion and refactoring), and scalability for large projects.

what is react?
- React is an open-source JavaScript library developed by Facebook.
- Used for building user interfaces, especially single-page applications (SPAs).
- Focuses on building UI components that can manage their own state.
- Uses a virtual DOM (Document Object Model) to optimize UI updates efficiently.
- Allows declarative programming, where you describe what the UI should look like, and React manages rendering.
- Supports JSX, a syntax extension that lets you write HTML-like code inside JavaScript.
- Widely used for creating dynamic, responsive web apps.

what is angular?
- Angular is an open-source web application framework developed by Google.
- A complete framework for building client-side SPAs.
- Uses TypeScript as its primary language.
- Follows a component-based architecture similar to React but includes built-in solutions for routing, state management, HTTP client, forms, and more.
- Uses two-way data binding to synchronize the model and the view automatically.
- Provides dependency injection, directives, pipes, and other powerful features.
- Well-suited for large-scale, enterprise-level applications.

lifecycles in angular/react

What are React Hooks?

Hooks are special functions that let you “hook into” React features like state and lifecycle from functional components.
Main React Hooks related to lifecycle:

    useState(initialValue)

        Lets you add state to functional components.

        Trigger: State updates trigger re-render.

    useEffect(callback, dependencies)

        Runs side effects in functional components.

        Combines behaviors of multiple lifecycle methods.



useEffect	Yes	Runs after render; replaces lifecycle methods for side effects.
useLayoutEffect	Yes	Runs synchronously after DOM updates; lifecycle-related.

Other Common React Hooks

1. useState(initialValue)
   - Adds state to functional components.
   - Returns a state variable and a setter function.
   - Causes component to re-render on state change.

2. useEffect(callback, dependencies)
   - Performs side effects after render.
   - Runs after first mount and whenever dependencies change.
   - Can return cleanup function to run before unmount or before next effect.

3. useContext(ContextObject)
   - Accesses React context value.
   - Makes it easier to share data (like themes, user info) without prop drilling.

4. useReducer(reducer, initialState)
   - An alternative to useState for complex state logic.
   - Similar to Redux reducer pattern.
   - Returns current state and dispatch function.


Angular Lifecycle Hooks and When They Are Called

1. ngOnChanges(changes: SimpleChanges)
   When: Called whenever data-bound input properties change, before ngOnInit on first change.
   Scenario: React to changes in @Input properties.

2. ngOnInit()
   When: Called once after the first ngOnChanges.
   Scenario: Initialize component, fetch data, setup logic.

3. ngDoCheck()
   When: Called during every change detection run, after ngOnChanges and ngOnInit.
   Scenario: Custom change detection beyond Angular’s default.

4. ngAfterContentInit()
   When: Called once after Angular projects external content into the component (via <ng-content>).
   Scenario: Initialization that depends on projected content.

5. ngAfterContentChecked()
   When: After each check of projected content.
   Scenario: Respond to changes in content projection.

6. ngAfterViewInit()
   When: Called once after component’s view (and child views) are initialized.
   Scenario: Initialization that depends on component’s template or child components.

7. ngAfterViewChecked()
   When: After each check of component’s views.
   Scenario: Respond to changes in the view.

8. ngOnDestroy()
   When: Just before Angular destroys the component.
   Scenario: Cleanup resources like subscriptions or event handlers.

what are observables? what is async? what are promises?
What are Observables?

- Observables are a programming concept used to handle asynchronous data streams.
- They represent a collection of future values or events that can be observed over time.
- You can subscribe to an observable to receive data updates, errors, or completion signals.
- Commonly used in frameworks like Angular with RxJS (Reactive Extensions for JavaScript).
- Observables support operators like map, filter, merge, which help transform data streams.
- They can emit multiple values over time (unlike promises, which resolve once).
- Example use case: Handling real-time data, user events, or HTTP requests that may emit multiple responses.

What is Async?

- "Async" stands for asynchronous programming, where operations run independently from the main program flow.
- It allows programs to handle time-consuming tasks (like network calls, file I/O) without blocking the execution.
- In JavaScript/TypeScript, async is often associated with async/await syntax to write asynchronous code that looks synchronous.
- Async programming improves performance and responsiveness, especially in UI applications.

What are Promises?

- Promises represent a single future value resulting from an asynchronous operation.
- They can be in one of three states: pending, fulfilled (resolved), or rejected.
- Promises allow chaining with `.then()` for success and `.catch()` for errors.
- Unlike observables, promises resolve once with a single value or error.
- They simplify asynchronous code management compared to callbacks.
- Often used for network requests, timers, or any async operation that returns a single result.

what is a shadow dom?
What is Shadow DOM?

- Shadow DOM is a web standard that enables encapsulation of DOM and CSS in web components.
- It allows a component to have its own isolated DOM subtree, separate from the main document DOM.
- Styles and scripts inside the shadow DOM do not affect the main page and vice versa.
- This encapsulation helps prevent CSS conflicts and keeps component implementation details hidden.
- Shadow DOM is a key part of building reusable and self-contained web components.
- Browsers support shadow DOM natively via the `attachShadow` method on elements.

Example use case:
- Creating a custom button component with styles that won’t be overridden or leak out.

What algorithms I should be aware of and where should we use them?
1. Quick Sort
- A fast, efficient sorting algorithm using divide and conquer.
- It picks a 'pivot' element, partitions the array into elements less and greater than the pivot, and recursively sorts them.
- Average time complexity: O(n log n).
- Used for sorting large datasets efficiently.

2. Binary Search
- Searches a sorted array by repeatedly dividing the search interval in half.
- Compares the target value to the middle element; eliminates half the array each step.
- Time complexity: O(log n).
- Used in searching for elements in sorted data structures.

3. Depth-First Search (DFS)
- Explores as far as possible along each branch before backtracking.
- Used to traverse or search tree and graph data structures.
- Useful in solving puzzles, maze solving, and detecting cycles.

4. Dynamic Programming (DP)
- Solves complex problems by breaking them down into simpler overlapping subproblems.
- Stores results of subproblems to avoid redundant calculations.
- Used in optimization problems like the Knapsack problem, Fibonacci sequence, and shortest path.

5. Breadth-First Search (BFS)
- Explores all neighbors at the present depth before moving on to nodes at the next depth level.
- Used in shortest path finding in unweighted graphs, level order traversal in trees.


what is hashing?
What is Hashing?

- Hashing is the process of converting input data of any size (like a string or file) into a fixed-size value called a hash code or hash value.
- This hash value is typically a number that represents the original data uniquely or nearly uniquely.
- Hash functions are designed to distribute inputs uniformly across the output range.
- Commonly used in data structures like hash tables, for quick data retrieval.
- Also used in cryptography, checksums, and data integrity verification.

what is the contract between hashcode and equals?
	If two objects are equal according to equals(), then they must have the same hashCode() value.
	If two objects have the same hashCode(), they are not necessarily equal.
	
What is a Hash Collision?

- A hash collision occurs when two different inputs produce the same hash value.
- Because hash functions map a large input space to a fixed-size output space, collisions are inevitable (pigeonhole principle).
- Collisions can degrade the performance of hash-based data structures if not handled properly.
- Collision resolution techniques include chaining (linked lists) and open addressing (probing).

some common coding exercises

// 1. Reverse a String
// Requirement: Return the reversed version of the input string.
// Explanation: Kotlin provides a built-in reversed() function.
fun reverseString(str: String): String {
    return str.reversed()
}

// 2. Find Maximum Number in Array
// Requirement: Return the largest number from the array.
// Explanation: Iterate through array and track max value.
fun findMax(arr: List<Int>): Int {
    var max = arr[0]
    for (num in arr) {
        if (num > max) max = num
    }
    return max
}

// 3. Check Palindrome String
// Requirement: Return true if string reads same backward and forward.
// Explanation: Use two pointers moving toward the center, compare characters.
fun isPalindrome(str: String): Boolean {
    var left = 0
    var right = str.length - 1
    while (left < right) {
        if (str[left] != str[right]) return false
        left++
        right--
    }
    return true
}

// 4. Fibonacci Number at Nth Position
// Requirement: Return the Nth Fibonacci number.
// Explanation: Use two variables and iterate to calculate the nth number.
fun fibonacci(n: Int): Int {
    if (n <= 1) return n
    var a = 0
    var b = 1
    for (i in 2..n) {
        val temp = a + b
        a = b
        b = temp
    }
    return b
}

// 5. Check Anagrams
// Requirement: Return true if two strings have the same characters in any order.
// Explanation: Convert to char arrays, sort, and compare.
fun areAnagrams(s1: String, s2: String): Boolean {
    return s1.toCharArray().sorted() == s2.toCharArray().sorted()
}

// 6. Remove Duplicates from Array
// Requirement: Return list with duplicates removed.
// Explanation: Convert to Set to remove duplicates, then back to List.
fun removeDuplicates(arr: List<Int>): List<Int> {
    return arr.toSet().toList()
}

// 7. Merge Two Sorted Arrays
// Requirement: Merge two sorted arrays into one sorted array.
// Explanation: Use two pointers to merge efficiently.
fun mergeSortedArrays(arr1: List<Int>, arr2: List<Int>): List<Int> {
    var i = 0
    var j = 0
    val merged = mutableListOf<Int>()
    while (i < arr1.size && j < arr2.size) {
        if (arr1[i] < arr2[j]) {
            merged.add(arr1[i++])
        } else {
            merged.add(arr2[j++])
        }
    }
    while (i < arr1.size) merged.add(arr1[i++])
    while (j < arr2.size) merged.add(arr2[j++])
    return merged
}

// 8. Find Factorial of a Number
// Requirement: Return factorial of n (n!).
// Explanation: Multiply numbers from 1 to n.
fun factorial(n: Int): Int {
    var result = 1
    for (i in 2..n) result *= i
    return result
}

// 9. Check if Number is Prime
// Requirement: Return true if number is prime.
// Explanation: Check divisibility from 2 to sqrt(n).
fun isPrime(n: Int): Boolean {
    if (n <= 1) return false
    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {
        if (n % i == 0) return false
    }
    return true
}

// 10. Find Second Largest Number
// Requirement: Return the second largest number in array.
// Explanation: Track largest and second largest while iterating.
fun secondLargest(arr: List<Int>): Int {
    var largest = Int.MIN_VALUE
    var second = Int.MIN_VALUE
    for (num in arr) {
        if (num > largest) {
            second = largest
            largest = num
        } else if (num > second && num != largest) {
            second = num
        }
    }
    return second
}

// 11. Count Vowels in String
// Requirement: Return number of vowels in the input string.
// Explanation: Iterate and count vowels (a,e,i,o,u).
fun countVowels(str: String): Int {
    val vowels = setOf('a', 'e', 'i', 'o', 'u')
    return str.lowercase().count { it in vowels }
}

// 12. Flatten Nested Array
// Requirement: Flatten arbitrarily nested arrays into one array.
// Explanation: Recursively flatten each element.
fun flattenArray(arr: List<Any>): List<Any> {
    val result = mutableListOf<Any>()
    for (el in arr) {
        if (el is List<*>) {
            result.addAll(flattenArray(el.filterNotNull()))
        } else {
            result.add(el)
        }
    }
    return result
}

// 13. Find Missing Number in 1 to N
// Requirement: Given array with numbers from 1 to N with one missing, find missing number.
// Explanation: Use sum formula.
fun findMissingNumber(arr: List<Int>, n: Int): Int {
    val expectedSum = n * (n + 1) / 2
    val actualSum = arr.sum()
    return expectedSum - actualSum
}

// 14. Implement FizzBuzz
// Requirement: Print numbers 1 to n, replace multiples of 3 with 'Fizz', 5 with 'Buzz', both with 'FizzBuzz'.
fun fizzBuzz(n: Int) {
    for (i in 1..n) {
        when {
            i % 15 == 0 -> println("FizzBuzz")
            i % 3 == 0 -> println("Fizz")
            i % 5 == 0 -> println("Buzz")
            else -> println(i)
        }
    }
}

// 15. Check if Two Arrays are Equal
// Requirement: Return true if both arrays have same elements in same order.
fun arraysEqual(arr1: List<Int>, arr2: List<Int>): Boolean {
    if (arr1.size != arr2.size) return false
    for (i in arr1.indices) {
        if (arr1[i] != arr2[i]) return false
    }
    return true
}

// 16. Count Occurrences of Characters in String
// Requirement: Return map with counts of each character in string.
fun charCount(str: String): Map<Char, Int> {
    val count = mutableMapOf<Char, Int>()
    for (ch in str) {
        count[ch] = count.getOrDefault(ch, 0) + 1
    }
    return count
}

// 17. Find Intersection of Two Arrays
// Requirement: Return list of elements common to both arrays.
fun intersection(arr1: List<Int>, arr2: List<Int>): List<Int> {
    val set2 = arr2.toSet()
    return arr1.filter { it in set2 }
}

// 18. Reverse Words in a Sentence
// Requirement: Reverse the order of words in a string sentence.
fun reverseWords(sentence: String): String {
    return sentence.split(" ").reversed().joinToString(" ")
}

// 19. Check if Number is Power of Two
// Requirement: Return true if number is power of two.
fun isPowerOfTwo(n: Int): Boolean {
    if (n <= 0) return false
    return (n and (n - 1)) == 0
}

// 20. Implement Binary Search
// Requirement: Search target in sorted array and return index or -1 if not found.
fun binarySearch(arr: List<Int>, target: Int): Int {
    var left = 0
    var right = arr.size - 1
    while (left <= right) {
        val mid = (left + right) / 2
        when {
            arr[mid] == target -> return mid
            arr[mid] < target -> left = mid + 1
            else -> right = mid - 1
        }
    }
    return -1
}

