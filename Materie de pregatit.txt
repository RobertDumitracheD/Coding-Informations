TOPICS
1. Streams - reduce/flatmap

In Java, streams are a powerful feature introduced in Java 8 as part of the java.util.stream package. S
treams allow you to perform various operations on collections of data in a functional-style manner, making code more concise, 
readable, and efficient.

Stream operations can be categorized into two types:

Intermediate Operations: These operations transform the stream into another stream, allowing chaining of multiple intermediate operations. 
Some common intermediate operations include filter, map, flatMap, distinct, sorted, peek, etc.

Terminal Operations: These operations produce a final result or side-effect. Once a terminal operation is applied to a stream, 
it cannot be reused. Examples of terminal operations are forEach, collect, reduce, count, min, max, etc.

Let's go through each important method, including reduce and flatMap, with examples:

filter: Filters elements based on a given predicate.
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());
// Output: [2, 4, 6, 8, 10]
map: Transforms each element of the stream into another value.

List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<Integer> nameLengths = names.stream()
                                 .map(String::length)
                                 .collect(Collectors.toList());
// Output: [5, 3, 7]

flatMap: Flattens nested collections and maps each element to a stream.
List<List<Integer>> nestedNumbers = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4, 5), Arrays.asList(6, 7, 8, 9));
List<Integer> flattenedNumbers = nestedNumbers.stream()
                                             .flatMap(Collection::stream)
                                             .collect(Collectors.toList());
// Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

distinct: Removes duplicate elements from the stream.
List<Integer> numbersWithDuplicates = Arrays.asList(1, 2, 3, 4, 3, 5, 2);
List<Integer> distinctNumbers = numbersWithDuplicates.stream()
                                                     .distinct()
                                                     .collect(Collectors.toList());
// Output: [1, 2, 3, 4, 5]


sorted: Sorts the elements of the stream.
List<Integer> unsortedNumbers = Arrays.asList(5, 2, 8, 1, 6, 3);
List<Integer> sortedNumbers = unsortedNumbers.stream()
                                             .sorted()
                                             .collect(Collectors.toList());
// Output: [1, 2, 3, 5, 6, 8]

reduce: Performs a reduction operation on the elements of the stream.
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);
// Output: 15 (1 + 2 + 3 + 4 + 5)

forEach: Applies an action to each element in the stream.
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream()
     .forEach(System.out::println);
// Output: Alice
//         Bob
//         Charlie

collect: Performs a mutable reduction operation on the elements of the stream.
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String concatenatedNames = names.stream()
                               .collect(Collectors.joining(", "));
// Output: "Alice, Bob, Charlie"

Function<T, R>: Represents a function that takes an argument of type T and returns a result of type R. It is used for mapping operations in streams.

Predicate<T>: Represents a function that takes an argument of type T and returns a boolean. It is used for filtering elements in streams.

Consumer<T>: Represents a function that takes an argument of type T and returns no result. It is used for actions like printing, collecting, etc.

Supplier<T>: Represents a function that produces a value of type T. It is used for generating values, e.g., in Stream.generate().

BinaryOperator<T>: Represents a function that takes two arguments of type T and returns a result of type T. It is used for reduction operations, 
like reduce() in streams.

BiFunction<T, U, R>: Represents a function that takes two arguments of types T and U and returns a result of type R. It is used in
 various stream operations.

BiPredicate<T, U>: Represents a function that takes two arguments of types T and U and returns a boolean. It is used in various stream operations.

map(Function<? super T,? extends R> mapper): Uses Function to transform elements in a stream.
filter(Predicate<? super T> predicate): Uses Predicate to filter elements in a stream.
forEach(Consumer<? super T> action): Uses Consumer to perform an action on each element in a stream.
reduce(BinaryOperator<T> accumulator): Uses BinaryOperator to combine elements in a stream.
collect(Collector<? super T, A, R> collector): Uses various functional interfaces in the Collector to accumulate elements into a collection.

==============================================================================================================================

2. Collections

Collection Interfaces:
List

Interface: java.util.List
Description: An ordered collection that allows duplicate elements. Elements are indexed, and you can access them by their index.
Common Implementations: ArrayList, LinkedList

add(E element): Adds an element to the end of the list.
add(int index, E element): Adds an element at a specific index in the list.
get(int index): Retrieves the element at the specified index.
remove(int index): Removes the element at the specified index.
size(): Returns the number of elements in the list.
contains(Object obj): Checks if the list contains a specific element.
indexOf(Object obj): Returns the index of the first occurrence of the specified element.
isEmpty(): Checks if the list is empty.
clear(): Removes all elements from the list.
subList(int fromIndex, int toIndex): Returns a view of the portion of the list between the specified fromIndex, 
inclusive, and toIndex, exclusive.

import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        System.out.println(list.get(0)); // Output: "Apple"
        System.out.println(list.size()); // Output: 3
    }
}


Set

Interface: java.util.Set
Description: An unordered collection that does not allow duplicate elements. Each element is unique.
Common Implementations: HashSet, TreeSet, LinkedHashSet

add(E element): Adds an element to the set.
remove(Object obj): Removes the specified element from the set.
contains(Object obj): Checks if the set contains a specific element.
size(): Returns the number of elements in the set.
isEmpty(): Checks if the set is empty.
clear(): Removes all elements from the set.

import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Orange");
        set.add("Banana"); // Duplicate element, will be ignored

        System.out.println(set.contains("Apple")); // Output: true
        System.out.println(set.size()); // Output: 3
    }
}


Queue

Interface: java.util.Queue
Description: A collection designed for holding elements before processing. It follows the FIFO (First-In-First-Out) order, but some implementations (e.g., PriorityQueue) may have different behavior based on element priority.
Common Implementations: LinkedList, PriorityQueue

add(E element): Adds an element to the queue.
remove(): Removes and returns the element at the head of the queue (FIFO).
element(): Retrieves, but does not remove, the element at the head of the queue.
offer(E element): Adds an element to the queue, returns true if successful, false if the queue is full.
poll(): Retrieves and removes the element at the head of the queue, returns null if the queue is empty.
peek(): Retrieves, but does not remove, the element at the head of the queue, returns null if the queue is empty.
size(): Returns the number of elements in the queue.
isEmpty(): Checks if the queue is empty.
clear(): Removes all elements from the queue.

import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.add("Apple");
        queue.add("Banana");
        queue.add("Orange");

        System.out.println(queue.poll()); // Output: "Apple"
        System.out.println(queue.size()); // Output: 2
    }
}


Deque

Interface: java.util.Deque
Description: A double-ended queue that allows insertion and deletion at both ends. It can also be used as a stack (LIFO - Last-In-First-Out) or a queue (FIFO - First-In-First-Out).
Common Implementations: ArrayDeque, LinkedList

addFirst(E element): Adds an element to the front of the deque.
addLast(E element): Adds an element to the end of the deque.
removeFirst(): Removes and returns the element at the front of the deque.
removeLast(): Removes and returns the element at the end of the deque.
offerFirst(E element): Adds an element to the front of the deque, returns true if successful, false if the deque is full.
offerLast(E element): Adds an element to the end of the deque, returns true if successful, false if the deque is full.
peekFirst(): Retrieves, but does not remove, the element at the front of the deque, returns null if the deque is empty.
peekLast(): Retrieves, but does not remove, the element at the end of the deque, returns null if the deque is empty.

import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        deque.add("Apple");
        deque.add("Banana");
        deque.add("Orange");

        System.out.println(deque.pop()); // Output: "Apple"
        System.out.println(deque.size()); // Output: 2
    }
}

==============================================================================================================================
2. Map interface

Map Interface:
The Map interface in Java represents a collection that maps keys to values. Each key in the map is unique, and it is associated 
with a corresponding value. 
The Map interface provides methods to manipulate key-value pairs efficiently.
Remember that Map is a powerful data structure for fast key-value lookups, and each implementation has specific use cases 
based on ordering requirements and performance characteristics. Choose the appropriate implementation based on your needs.
Important methods of the Map interface:

put(K key, V value): Associates the specified value with the specified key in the map.
get(Object key): Returns the value associated with the given key, or null if the key is not present in the map.
remove(Object key): Removes the key-value pair associated with the given key from the map.
containsKey(Object key): Checks if the map contains a specific key.
containsValue(Object value): Checks if the map contains a specific value.
size(): Returns the number of key-value pairs in the map.
isEmpty(): Checks if the map is empty.
keySet(): Returns a set of all the keys in the map.
values(): Returns a collection of all the values in the map.
entrySet(): Returns a set of key-value pairs (Map.Entry) in the map.

HashMap:
Description: A hash table-based implementation of the Map interface. It provides constant-time average complexity for basic operations (put, get, remove).
Important Details: Elements in a HashMap are not ordered.
Example:
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> ages = new HashMap<>();
        ages.put("Alice", 30);
        ages.put("Bob", 25);
        ages.put("Charlie", 35);

        System.out.println(ages.get("Alice")); // Output: 30
        System.out.println(ages.containsKey("Bob")); // Output: true
        System.out.println(ages.size()); // Output: 3
    }
}

TreeMap:
Description: A Red-Black tree-based implementation of the Map interface. It maintains elements in sorted order based on their keys.
Important Details: Elements in a TreeMap are ordered by their natural ordering or a custom comparator.
Example:
import java.util.TreeMap;
import java.util.Map;

public class TreeMapExample {
    public static void main(String[] args) {
        TreeMap<String, Integer> ages = new TreeMap<>();
        ages.put("Alice", 30);
        ages.put("Bob", 25);
        ages.put("Charlie", 35);

        System.out.println(ages.get("Charlie")); // Output: 35
        System.out.println(ages.firstKey()); // Output: "Alice"
        System.out.println(ages.size()); // Output: 3
    }
}

LinkedHashMap:
Description: A hash table-based implementation of the Map interface with a predictable iteration order (insertion order).
Important Details: Elements in a LinkedHashMap are ordered by their insertion order.
Example:
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        LinkedHashMap<String, Integer> ages = new LinkedHashMap<>();
        ages.put("Alice", 30);
        ages.put("Bob", 25);
        ages.put("Charlie", 35);

        System.out.println(ages.get("Bob")); // Output: 25
        System.out.println(ages.keySet()); // Output: [Alice, Bob, Charlie]
        System.out.println(ages.size()); // Output: 3
    }
}

==============================================================================================================================



3. SOLID Principles

The SOLID principles are a set of five design principles for writing maintainable and scalable object-oriented software. 
Each principle focuses on specific aspects of software design to promote flexibility, maintainability, and modularity.
Applying the SOLID principles leads to more maintainable, extensible, and robust software designs. By adhering to these principles, 
you can create code that is easier to understand, modify, and test.

a.Single Responsibility Principle (SRP):
	Principle: A class should have only one reason to change, meaning it should have only one responsibility.
	Explanation: A class should be designed to handle a single responsibility or functionality. This helps in maintaining the 
	code and making it easier to understand and modify.
	Example: Consider a class called EmailSender that is responsible for sending emails. If you also add the responsibility of
	 generating email content to this class, it violates the SRP. 
	Instead, you can create a separate class EmailContentGenerator that handles email content generation.
	
b.Open/Closed Principle (OCP):

	Principle: Software entities should be open for extension but closed for modification.
	Explanation: Once a class is written and tested, it should not be modified to add new features. Instead, you should extend 
	the class and override its behavior to add new functionality.
	Example: Suppose you have a class Shape with a method area() for calculating the area. Instead of modifying the Shape class 
	to add a new shape (e.g., Triangle), you can create a new class Triangle that extends Shape and provides its own implementation of the area() 
	method.
	
c.Liskov Substitution Principle (LSP):

	Principle: Subtypes should be substitutable for their base types.
	Explanation: If a class is a subclass of another class, it should be usable in place of its parent class without affecting 
	the correctness of the program.
	Example: Consider a class hierarchy with a base class Bird and subclasses Duck and Penguin. If you have a method that takes a 
	Bird parameter, you should be able to pass either a Duck or a Penguin without causing issues.
	
d.Interface Segregation Principle (ISP):

	Principle: A client should not be forced to depend on interfaces it does not use.
	Explanation: Instead of creating large interfaces with many methods, separate them into smaller, more specific interfaces. 
	Clients should only depend on the interfaces that are relevant to them.
	Example: Suppose you have an interface Printer with methods print() and scan(). If a client only needs printing functionality, 
	it should not be forced to implement the unnecessary scan() method. Separate the interface into Printable and Scannable interfaces.
	
e.Dependency Inversion Principle (DIP):

	Principle: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not 
	depend on details. Details should depend on abstractions.
	Explanation: Rather than depending on concrete implementations, code should depend on abstractions (interfaces or abstract classes). 
	This promotes loose coupling and flexibility in the design.
	Example: Instead of directly instantiating a concrete class inside another class, use dependency injecti
	
==============================================================================================================================
	
4. Spring Boot

What is Spring Boot?

Explanation: Spring Boot is an opinionated framework built on top of the Spring Framework that aims to simplify the development of Spring-based 
applications. It provides a set of conventions, sensible defaults, and auto-configuration, reducing the need for manual configuration. 
Spring Boot helps you quickly set up and run production-grade Spring applications with minimal effort.

Example: With Spring Boot, you can create a RESTful web service with just a few annotations and dependencies. The framework handles most 
of the configuration, allowing you to focus on implementing business logic.
Auto-Configuration and Starter Dependencies
Explanation: Spring Boot's auto-configuration feature automatically configures beans and components based on the classpath and the 
dependencies you include in your project. It leverages Spring Boot Starter dependencies to add common configurations for specific purposes (
e.g., Spring Web Starter for web applications, Spring Data JPA Starter for JPA-based data access).

Example: By adding the spring-boot-starter-web dependency to your project, Spring Boot automatically configures a web application with 
embedded Tomcat as the default servlet container, eliminating the need for explicit servlet container configuration.
Spring Boot Actuator
Explanation: Spring Boot Actuator provides production-ready features to monitor and manage applications. It offers endpoints that 
expose useful information about the application, such as health, metrics, environment properties, etc.

Example: By adding the spring-boot-starter-actuator dependency and enabling the relevant endpoints in the configuration, you can
 monitor the health of your application by accessing the /actuator/health endpoint.
External Configuration
Explanation: Spring Boot supports external configuration through properties files, YAML files, environment variables, and command-line 
arguments. The framework automatically binds the properties to Java objects using the @ConfigurationProperties annotation.

Example: You can define application properties in a application.properties file, and Spring Boot will automatically read and populate
 the properties in your application configuration classes.
Spring Boot Starters
Explanation: Spring Boot Starters are convenient sets of dependencies that simplify project setup for specific use cases. They group 
related dependencies together to provide an out-of-the-box solution for various application types.

Example: The spring-boot-starter-data-jpa starter includes all the necessary dependencies to use Spring Data JPA for database access,
 including Hibernate, HikariCP, and a supported database driver.
Embedded Server
Explanation: Spring Boot allows you to create self-contained executable JAR files that embed a servlet container (Tomcat, Jetty, or Undertow). 
This eliminates the need for deploying your application to an external server.

Example: By default, Spring Boot embeds Tomcat as the embedded server. You can choose a different embedded server by excluding the Tomcat 
starter and including another one.
Profiles
Explanation: Profiles in Spring Boot allow you to configure and activate different sets of properties based on the application's environment (
development, production, testing, etc.).

Example: By using profiles, you can define different database configurations for development and production environments, ensuring that 
the correct configuration is used depending on the context.
These are just some of the essential aspects of Spring Boot that a senior Java programmer should be familiar with. Spring Boot's ease 
of use, auto-configuration, and powerful features make it a popular choice for developing modern Java applications. Familiarizing 
yourself with these concepts will help you efficiently build robust and scalable applications using Spring Boot.


Beans in Spring Boot:
In Spring Boot (and the Spring Framework in general), a bean is an object that is managed by the Spring container 
(ApplicationContext). The Spring container is responsible for creating, initializing, and managing these beans' lifecycle. 
Beans can be Java objects representing various components, services, data sources, etc.

To create a bean, you typically define it as a Spring component using annotations. These components are then scanned and 
registered with the Spring container during application startup. Spring Boot's auto-configuration feature further simplifies bean creation and management.

Commonly Used Annotations in Spring Boot:
@SpringBootApplication:
Annotation: @SpringBootApplication
Description: The main annotation used to indicate the Spring Boot application's main class. It combines @Configuration, 
@EnableAutoConfiguration, and @ComponentScan.
Example:
@SpringBootApplication
public class MySpringBootApplication {
    public static void main(String[] args) {
        SpringApplication.run(MySpringBootApplication.class, args);
    }
}

@Controller:
Annotation: @Controller
Description: Marks a class as a Spring MVC controller that handles HTTP requests.
Example:
@Controller
public class MyController {
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello, Spring Boot!";
    }
}


@Service:
Annotation: @Service
Description: Marks a class as a service component. It is typically used for business logic implementations.
Example:
@Service
public class MyService {
    public String getGreeting() {
        return "Hello from the service!";
    }
}

@Repository:
Annotation: @Repository
Description: Marks a class as a repository component, often used for data access and database operations.
Example
@Repository:
Annotation: @Repository
Description: Marks a class as a repository component, often used for data access and database operations.
Example
@Repository
public class MyRepository {
    public String getData() {
        // Database access logic here
    }
}

@Autowired:
Annotation: @Autowired
Description: Used to automatically wire (inject) dependencies into a class.
Example:
@Autowired:
Annotation: @Autowired
Description: Used to automatically wire (inject) dependencies into a class.
Example:
@Service
public class MyService {
    private final MyRepository myRepository;

    @Autowired
    public MyService(MyRepository myRepository) {
        this.myRepository = myRepository;
    }

    // Rest of the service logic
}


@ConfigurationProperties:
Annotation: @ConfigurationProperties
Description: Binds and maps external configuration properties to a Java object.
Example:
@ConfigurationProperties(prefix = "myapp")
public class MyAppProperties {
    private String name;
    private int timeout;

    // Getters and setters
}

@Value:
Annotation: @Value
Description: Injects a single value from the Spring environment or properties file into a field or method parameter.
Example:
@Service
public class MyService {
    @Value("${myapp.timeout}")
    private int timeout;

    // Rest of the service logic
}

==============================================================================================================================

5. Spring JPA - Hibernate


==============================================================================================================================

6. Spring Web
Spring Web Annotations:
a. @Controller: This annotation is used to mark a class as a Spring MVC controller. It enables the class to handle incoming HTTP 
requests and return responses to the client.

b. @RestController: This annotation combines @Controller and @ResponseBody. It is specifically used for building RESTful 
APIs, where the methods' return values are automatically serialized to JSON/XML and sent as the response.

c. @RequestMapping: This annotation is used to map the incoming HTTP requests to the appropriate controller methods. 
It allows you to specify the request method, URI, headers, and other parameters to define the request mapping.

d. @PathVariable: This annotation is used to extract values from the URI path and bind them to the method parameters.

e. @RequestParam: This annotation is used to extract values from the query parameters of the URL and bind them to the method parameters.

f. @RequestBody: This annotation is used to map the request body to a method parameter, especially useful when dealing
 with JSON or XML data in the request body.

g. @ResponseStatus: This annotation is used to specify the HTTP status code to be returned by a controller method.

h. @ModelAttribute: This annotation is used to bind method parameters to model attributes, which will be automatically 
included in the model for views.

i. @SessionAttributes: This annotation is used to specify which model attributes should be kept in the session between requests.

j. @InitBinder: This annotation is used to customize the data binding process for certain form fields.

Best Practices for Spring Web:
a. Keep Controller Classes Thin: Try to keep your controller classes focused on handling HTTP requests and delegating 
business logic to service classes. This helps in separating concerns and makes the codebase more maintainable.

b. Use Appropriate HTTP Methods: Use HTTP methods like GET, POST, PUT, DELETE, etc., properly to represent the CRUD 
operations and follow RESTful principles.

c. Validation: Implement input validation for user-submitted data, using tools like Spring's validation annotations 
(@Valid, @NotBlank, etc.) or custom validation logic.

d. Error Handling: Implement a centralized error handling mechanism to handle exceptions and return appropriate error responses to the client.

e. Avoid Business Logic in Controllers: Business logic should be placed in service classes, not in controllers. Controllers 
should only be responsible for handling HTTP-related tasks.

f. Use DTOs (Data Transfer Objects): When dealing with RESTful APIs, use DTOs to transfer data between the client and server.
 This ensures that you have control over the data being sent and received.

g. Security Considerations: Implement appropriate security measures such as authentication and authorization using Spring Security.

h. Testing: Write unit tests for your controllers and integration tests for the entire application to ensure that everything
 is functioning as expected.

i. Versioning: If you are building a public API, consider versioning your API to handle future changes without breaking existing clients.

j. Optimization: Optimize your application's performance by using caching, minimizing database queries, and following best 
practices for handling resources.

==============================================================================================================================

7. Spring security

Spring Security is a powerful framework provided by the Spring ecosystem that focuses on providing security solutions for Java-based a
pplications, particularly web applications. It helps developers implement authentication, authorization, and other security-related functionalities to safeguard their applications from unauthorized access and attacks. Below are some important annotations and information related to Spring Security as of my last update in September 2021:

Spring Security Annotations:
a. @EnableWebSecurity: This annotation enables Spring Security for your application. You typically add this annotation 
to a configuration class that extends WebSecurityConfigurerAdapter.

b. @Secured: This annotation is used to secure a specific method or endpoint. It can be applied to controller methods to 
specify which roles or authorities are allowed to access them.

c. @PreAuthorize and @PostAuthorize: These annotations provide more fine-grained control over method security. They allow
 you to define expressions to determine whether a method can be executed based on certain conditions, such as user roles or argument values.

d. @AuthenticationPrincipal: This annotation is used to access the currently authenticated user's principal object in a 
controller method.

e. @EnableGlobalMethodSecurity: This annotation is used to enable method-level security using annotations like @Secured, 
@PreAuthorize, and @PostAuthorize.

f. @Order: This annotation is used to specify the order in which security configurations should be applied. A lower order 
value takes precedence over a higher value.

@Configuration
@RequiredArgsConstructor
@EnableWebSecurity
public class AuthorizationServerConfig {

    @Value("${oauth2.client.clientId}")
    private String client;
    @Value("${oauth2.client.clientSecret}")
    private String clientSecret;
    private final CORSCustomizer corsCustomizer;
//
//    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    private final CustomUserDetailsService customUserDetailsService;

//    private final TokenService tokenService;


    @Bean
    @Order(1)
    public SecurityFilterChain asFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);
        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)
                .oidc(Customizer.withDefaults());

        http.exceptionHandling(e ->
                        e.authenticationEntryPoint(
                                new LoginUrlAuthenticationEntryPoint("/login")
                        ))
                .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
        corsCustomizer.corsCustomizer(http);
        return http
                .logout(logout->logout.clearAuthentication(true)
                        .clearAuthentication(true)
                        .logoutSuccessUrl("http://127.0.0.1:4200/login")
                        .deleteCookies("JSESSIONID")
                        .invalidateHttpSession(true)
                        .permitAll())
                .formLogin(Customizer.withDefaults())
                .csrf(Customizer.withDefaults())
                .authenticationProvider(authenticationProvider())

                .sessionManagement(session->{
                    session.sessionAuthenticationStrategy(sessionAuthenticationStrategy());
                })
                .build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain appsecurityFilterChain(HttpSecurity http) throws Exception {
        HeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(
                new ClearSiteDataHeaderWriter(ClearSiteDataHeaderWriter.Directive.COOKIES));
        corsCustomizer.corsCustomizer(http);
        return http
                .formLogin(Customizer.withDefaults())
                .authorizeHttpRequests(httpRequests -> {
                    httpRequests.anyRequest().authenticated();
                })
                .oauth2ResourceServer(oauth2 -> {
                    oauth2.jwt(jwt -> jwt.jwkSetUri("http://localhost:8080/oauth2/jwks"));
                })
                .build();

    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(customUserDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
//
//    @Bean
//    public LogoutFilter logoutFilter() {
//        LogoutFilter logoutFilter = new LogoutFilter("/login", logoutHandlers());
//        logoutFilter.setFilterProcessesUrl("/logout");
//        return logoutFilter;
//    }
//
//    // LogoutHandlers to remove the JSESSIONID
//    private LogoutHandler[] logoutHandlers() {
//        SecurityContextLogoutHandler securityContextLogoutHandler = new SecurityContextLogoutHandler();
//        securityContextLogoutHandler.setClearAuthentication(true);
//        securityContextLogoutHandler.setInvalidateHttpSession(true);
//        return new LogoutHandler[]{securityContextLogoutHandler};
//    }

    @Bean
    public SessionAuthenticationStrategy sessionAuthenticationStrategy() {
        return new ChangeSessionIdAuthenticationStrategy();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }


    @Bean
    public PasswordEncoder passwordEncoder() {
        return  NoOpPasswordEncoder.getInstance();
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient r = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId(this.client)
                .clientSecret(this.clientSecret)
                .scope(OidcScopes.OPENID)
                .redirectUri("http://127.0.0.1:4200/authorized")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .tokenSettings(
                        TokenSettings.builder()
                                .accessTokenTimeToLive(Duration.ofHours(10))
                                .refreshTokenTimeToLive(Duration.ofHours(10)).build()
                )
                .clientSettings(ClientSettings.builder()
                        .requireAuthorizationConsent(true).build()
                )
                .build();
        return new InMemoryRegisteredClientRepository(r);
    }


    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://localhost:8080").build();
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair kp = keyPairGenerator.generateKeyPair();
        RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) kp.getPrivate();
//        tokenService.populatePrivateKey(privateKey);
        RSAKey key = new RSAKey.Builder(publicKey).privateKey(privateKey).keyID(UUID.randomUUID().toString()).build();

        JWKSet set = new JWKSet(key);
        return new ImmutableJWKSet<>(set);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }


OAuth 2.0 Public Key Credential Exchange (PKCE) is an extension to the OAuth 2.0 authorization framework that provides enhanced 
security for native and mobile applications. 
PKCE was introduced to address certain security vulnerabilities in OAuth 2.0 when used in public clients, such as mobile apps and 
single-page applications (SPAs). Below is an overview of OAuth 2.0 PKCE and its key features:

Background and Motivation:
In the traditional OAuth 2.0 flow, a public client (e.g., mobile app or SPA) requests an access token directly from the authorization server, 
using a client ID and optionally a client secret. However, these public clients can be susceptible to security threats, such as code
 interception attacks. PKCE was introduced to mitigate these risks.

Key Features of PKCE:

a. Code Verifier and Code Challenge: With PKCE, the client generates a random cryptographic code verifier and transforms it into 
a code challenge. The code challenge is sent to the authorization server during the authorization request.

b. Code Challenge Methods: PKCE allows multiple methods for transforming the code verifier into the code challenge. The most 
common method is the S256 method, which uses SHA-256 to hash the code verifier.

c. Enhanced Security: PKCE prevents certain attacks, such as the Authorization Code Intercept Attack, where a malicious actor 
intercepts the authorization code to gain unauthorized access.

d. Authorization Code Flow with PKCE: The authorization code flow with PKCE is similar to the traditional authorization code flow, 
but it includes an additional step where the client sends the code challenge during the authorization request and includes the code 
verifier during the token request.

PKCE Flow in Brief:

The PKCE flow includes the following steps:

i. The client generates a random code verifier and transforms it into a code challenge using the chosen method (e.g., S256).

ii. The client initiates the authorization request with the code challenge.

iii. The authorization server generates an authorization code and associates it with the code challenge.

iv. The client exchanges the authorization code along with the original code verifier during the token request.

v. The authorization server validates the code verifier and provides the access token.

Use Cases:

PKCE is primarily used in scenarios where a public client cannot securely store a client secret, such as native mobile apps and SPAs.

 It ensures that the authorization code cannot be used by malicious actors, even if intercepted.

Implementation:

Implementing PKCE involves making some changes to the OAuth 2.0 authorization flow in your client application to generate code verifiers 
and include them in the authorization and token requests. The server-side authorization server needs to support PKCE to validate the code challenge and provide enhanced security.

PKCE significantly improves the security of OAuth 2.0 flows for public clients and is recommended for use in native mobile apps and SPAs.
 It adds an additional layer of protection against certain security threats, making it a valuable extension to OAuth 2.0.


==============================================================================================================================
8. Multithreading

Multithreading is a programming concept where multiple threads within a single process execute independently, sharing the same
 resources but running concurrently. Threads are the smallest units of execution that can be scheduled by the operating system's 
 thread scheduler. Multithreading is commonly used to achieve concurrent execution, improve performance, and utilize modern 
 multi-core processors efficiently. 
Here's an overview of key aspects of multithreading:


1 / 2

Multithreading is a programming concept where multiple threads within a single process execute independently, 
sharing the same resources but running concurrently. Threads are the smallest units of execution that can be scheduled by the operating system's thread scheduler. Multithreading is commonly used to achieve concurrent execution, improve performance, and utilize modern multi-core processors efficiently. Here's an overview of key aspects of multithreading:

Threads vs. Processes:

Threads: Threads are lightweight and share the same memory space as their parent process. They can communicate 
and synchronize with each other easily.
Processes: Processes are heavyweight and have their own memory space. Inter-process communication (IPC) mechanisms are used to communicate between processes.
Advantages of Multithreading:

Improved Performance: Multithreading allows programs to execute multiple tasks concurrently, which can lead to better 
utilization of CPU resources and reduced execution time.
Responsiveness: Multithreading helps maintain application responsiveness by allowing background tasks to run without blocking the 
user interface thread.
Resource Sharing: Threads within the same process can share data, which can be useful for collaboration and resource utilization.
Challenges and Considerations:

Thread Safety: When multiple threads access and modify shared data simultaneously, it can lead to data inconsistency
 and race conditions. Proper synchronization techniques like locks and semaphores are required to ensure thread safety.
Deadlocks: Deadlocks occur when two or more threads are unable to proceed because each is waiting for the other to release a resource.
Starvation: A thread may be prevented from executing indefinitely due to unfair scheduling, resulting in starvation.


Synchronization:

Synchronization is essential to prevent data races and ensure thread safety. In Java, you can use synchronized blocks 
or the synchronized keyword to protect critical sections of code from concurrent access.
Other synchronization mechanisms include locks, semaphores, mutexes, and condition variables.
Thread States:

Threads can exist in different states, such as New, Runnable, Blocked, Waiting, Timed Waiting, and Terminated. The thread 
scheduler switches between these states based on thread priorities and available resources.

Creating Threads:

In Java, you can create threads in two main ways:

a. By extending the Thread class:
class MyThread extends Thread {
    public void run() {
        // Thread logic here
    }
}

MyThread thread = new MyThread();
thread.start(); // Starts the thread, invoking the run() method.
class MyRunnable implements Runnable {
    public void run() {
        // Thread logic here
    }
}

Thread thread = new Thread(new MyRunnable());
thread.start(); // Starts the thread, invoking the run() method.


. By implementing the Runnable interface:

Thread States and Lifecycle:
class MyRunnable implements Runnable {
    public void run() {
        // Thread logic here
    }
}

Thread thread = new Thread(new MyRunnable());
thread.start(); // Starts the thread, invoking the run() method.


Threads in Java go through different states during their lifecycle, such as:

NEW: The thread is created but has not yet started.
RUNNABLE: The thread is running or ready to run.
BLOCKED: The thread is blocked, waiting for a monitor lock.
WAITING and TIMED_WAITING: The thread is waiting for a specific condition, either indefinitely or for a specified period.
TERMINATED: The thread has completed its execution and is no longer running.
Thread Synchronization:

In multithreading, shared resources can be accessed concurrently, leading to race conditions and data inconsistency. Java provides various synchronization mechanisms to address this, including:

synchronized keyword: Used to create synchronized blocks or methods to protect critical sections of code.
Lock interface: Provides more flexible locking mechanisms, such as ReentrantLock.
volatile keyword: Used to ensure visibility of variables across threads.
wait() and notify() methods: Used for inter-thread communication and signaling.
Thread Pools:

Managing threads individually can be inefficient and resource-consuming. Java provides a high-level abstraction called 
ExecutorService, which manages a pool of threads and allows you to submit tasks for execution. This helps avoid the overhead 
of creating and destroying threads frequently.

Thread Priorities:

Java threads can be assigned priorities ranging from MIN_PRIORITY (1) to MAX_PRIORITY (10), with NORM_PRIORITY (5) being the default. 
The thread scheduler uses these priorities to decide which thread gets more CPU time.

Thread Interruption:

Threads can be interrupted using the interrupt() method. This is a cooperative mechanism to signal a thread to stop what it's doing and 
terminate gracefully.

Thread Safety and Best Practices:

To ensure thread safety, synchronize shared data, use immutable objects, prefer thread-safe data structures, and avoid unnecessary 
shared state whenever possible.

Java's multithreading capabilities provide a powerful way to write concurrent and parallel programs. However, writing correct and efficient 
multithreaded code can be challenging. It's essential to understand the concepts of synchronization, 
thread communication, and thread safety to avoid common pitfalls associated with multithreading.

Which approach should you choose?

If you need a simple thread and don't require the additional features of a custom class, extending Thread can be convenient. 
However, keep in mind the limitation of single inheritance.
If you want more flexibility and better separation of concerns, implementing Runnable is often preferred. 
It allows you to create threads with custom logic while keeping your class free to extend other classes or implement other interfaces

==============================================================================================================================
9. Design Patterns

Design patterns are reusable solutions to commonly occurring software design problems. 

They provide proven ways to solve design challenges, improve code organization, maintainability, 
and promote best practices in software development. In Java, various design patterns are used to address different design scenarios. Here are some popular design patterns in Java:

Singleton Pattern:
Ensures that a class has only one instance and provides a global point of access to that instance.
Use a singleton to represent a configuration manager that manages application-wide settings and ensures that only one instance 
of the configuration is used throughout the application.

Factory Pattern:
Provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created.
Implement a factory pattern to create different types of payment processors based on the type of payment (e.g., credit card, PayPal) 
in an e-commerce application.

Abstract Factory Pattern:
Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
Use an abstract factory pattern to create families of related objects, such as GUI components (buttons, text fields, etc.), 
based on the selected theme in a desktop application.

Builder Pattern:
Separates the construction of a complex object from its representation, allowing the same construction process to 
create different representations.
Use a builder pattern to create complex objects step-by-step, such as constructing an email with 
attachments and multiple recipients in an email client.

Prototype Pattern:
Allows creating new objects by copying an existing object, thus avoiding the need for expensive object creation.
Use a prototype pattern to clone existing complex objects and customize them with minimal overhead, like cloning a pre-configured user 
profile to create new user accounts.

Adapter Pattern:
Converts the interface of a class into another interface that clients expect, allowing classes with incompatible interfaces to work together.
Implement an adapter pattern to integrate a third-party payment gateway into an existing payment processing system, converting the 
third-party interface 
to match the system's expected interface.

Decorator Pattern:
Adds additional functionality to an object dynamically, allowing behavior to be extended without affecting other objects of the same class.
Use a decorator pattern to add additional features to a text editor, such as spell checking or auto-capitalization, without modifying 
the original editor code.

Composite Pattern:
Treats individual objects and compositions of objects uniformly, allowing clients to work with complex object structures.
Apply a composite pattern to represent hierarchical structures, like modeling a directory structure in a file system.

Proxy Pattern:
Provides a surrogate or placeholder for another object, controlling access to the original object or adding additional functionality.
Use a proxy pattern to provide a lightweight placeholder for expensive-to-create objects, like lazy-loading large images in a photo gallery.

Observer Pattern:
Defines a dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically.
Implement an observer pattern to notify multiple modules in a system when a critical event, like a system error, occurs.

Strategy Pattern:
Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Clients can switch algorithms at runtime.
Apply a strategy pattern to allow users to select different sorting algorithms (bubble sort, merge sort, etc.) in a data analysis application.

Template Method Pattern:
Defines the skeleton of an algorithm in a method, allowing subclasses to provide specific implementations of some steps.
Use a template method pattern to define the overall structure of an algorithm in a base class and allow subclasses to provide 
specific implementations for certain steps.

State Pattern:
Allows an object to change its behavior when its internal state changes.
Apply a state pattern to model the behavior of a vending machine based on its current state (e.g., idle, dispensing, out of stock).

Command Pattern:
Encapsulates a request as an object, thereby allowing parameterization of clients with different requests, queuing of requests, 
and logging of the requests.
Implement a command pattern to encapsulate user actions in an application, allowing undo and redo functionality.

Iterator Pattern:
Provides a way to access elements of a collection sequentially without exposing its underlying representation.
Use an iterator pattern to traverse and access elements of a collection without exposing its internal representation.


==============================================================================================================================
10. Data structures


Sure! Here are examples of how each data structure can be used in various scenarios:

Arrays:

Storing a list of student names in an online registration system.
Representing pixel values of an image for image processing.

Linked Lists:

Implementing a music playlist where each song is a node pointing to the next song.
Implementing undo and redo functionality in a text editor.

Stacks:

Evaluating mathematical expressions using the postfix notation (reverse Polish notation).
Implementing a web browser's back button functionality.

Queues:

Managing print jobs in a printer's spooling system.
Implementing a request processing system in a web server.

Trees:

Representing a file system hierarchy with directories and files as nodes.
Implementing hierarchical data structures like binary search trees for fast search and retrieval.

Graphs:

Representing social networks, where users are nodes, and connections are edges.
Solving problems like finding the shortest path between two locations on a map.

Hash Tables:

Implementing a dictionary or a spell-checking system with word lookups in constant time.
Avoiding duplicate entries in a list by using a hash set.

Heaps:

Implementing priority queues for tasks with different priorities, such as a job scheduling system.
Efficiently finding the kth largest or smallest element in a list.

Tries:

Implementing an autocomplete feature in a search engine.
Storing a dictionary of words for efficient prefix-based lookups.

Hash Sets and Hash Maps:

Checking for duplicates in a large dataset by using a hash set.
Implementing a phonebook, where names are keys and phone numbers are values in a hash map.
These examples highlight the versatility of different data structures and their applications in solving real-world problems. 
Properly choosing and implementing the appropriate data structure is essential for optimizing the performance and efficiency of software solutions.

==============================================================================================================================
11. Tests

Unit testing is a crucial aspect of developing Spring Boot applications to ensure that individual components and units of code work correctly 
in isolation.
 Spring Boot provides support for unit testing using various testing frameworks. Here's how you can perform unit testing in Spring Boot:

Testing Dependencies:
Ensure that you have the required testing dependencies in your project. Spring Boot includes the necessary testing dependencies by default 
in its starter packages. Common testing libraries used in Spring Boot projects include JUnit, Mockito, and AssertJ.

Testing Annotations:
Spring Boot provides testing annotations like @SpringBootTest, @RunWith(SpringRunner.class), and @MockBean that help set up the Spring context 
and manage dependencies during testing.

Testing the Application Context:
Use the @SpringBootTest annotation to create an application context for your tests. This annotation loads the Spring context and initializes 
the beans, making it possible to test the application as if it were running.

Mocking Dependencies:
To isolate units of code from their dependencies, you can use mocking frameworks like Mockito. The @MockBean annotation allows you to create 
a mock of a Spring bean, which you can then configure to return specific values during testing.

Test Configuration:
Create test-specific configurations using @TestConfiguration or @Configuration classes. These configurations help you customize the bean 
creation process specifically for testing purposes.

Testing Controllers:
Use MockMvc to test Spring MVC controllers. It allows you to perform HTTP requests and validate responses without actually starting a server.

Testing Services:
When testing services, you can mock dependencies using @MockBean, and then use Mockito.when() to specify the behavior of those mocked dependencies.

Testing Repositories:
For repository testing, you can use an in-memory database like H2 or configure test-specific profiles to use a separate database.

Integration Testing:
For more comprehensive testing, you can perform integration tests using @SpringBootTest with a real application context. Integration 
tests focus on testing the interactions between different components of your application.

Asserting Test Results:
Use assertion libraries like JUnit's assertEquals(), AssertJ's fluent assertions, or Hamcrest's matchers to verify that the actual results 
match the expected ones.

Testing with Test Templates:
Spring Boot provides Test templates that help simplify and speed up the creation of different types of tests. Examples include @DataJpaTest, 
@WebMvcTest, and @RestClientTest.

Remember to maintain a good balance between unit testing, integration testing, and end-to-end testing to achieve a comprehensive and reliable 
test suite for your Spring Boot application.

Example:
@Service
public class CalculatorService {

    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public int divide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Cannot divide by zero");
        }
        return a / b;
    }
}
@RunWith(MockitoJUnitRunner.class)
public class CalculatorServiceTest {

    @InjectMocks
    private CalculatorService calculatorService;

    @Test
    public void testAdd() {
        int result = calculatorService.add(10, 20);
        assertEquals(30, result);
    }

    @Test
    public void testSubtract() {
        int result = calculatorService.subtract(20, 10);
        assertEquals(10, result);
    }

    @Test
    public void testMultiply() {
        int result = calculatorService.multiply(5, 6);
        assertEquals(30, result);
    }

    @Test
    public void testDivide() {
        int result = calculatorService.divide(20, 5);
        assertEquals(4, result);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testDivideByZero() {
        calculatorService.divide(20, 0);
    }
}

Rest Test Example:

public class Book {
    private Long id;
    private String title;
    private String author;

    // Getters and setters
}

@RestController
@RequestMapping("/api/books")
public class BookController {

    private List<Book> books = new ArrayList<>();

    @GetMapping
    public List<Book> getAllBooks() {
        return books;
    }

    @GetMapping("/{id}")
    public ResponseEntity<Book> getBookById(@PathVariable Long id) {
        Book book = books.stream()
                .filter(b -> b.getId().equals(id))
                .findFirst()
                .orElse(null);

        if (book != null) {
            return ResponseEntity.ok(book);
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    @PostMapping
    public ResponseEntity<Book> addBook(@RequestBody Book book) {
        books.add(book);
        return ResponseEntity.status(HttpStatus.CREATED).body(book);
    }

    // Other methods for updating and deleting books
}

@RunWith(SpringRunner.class)
@WebMvcTest(BookController.class)
public class BookControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testGetAllBooks() throws Exception {
        mockMvc.perform(get("/api/books"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$", hasSize(0)));
    }

    @Test
    public void testGetBookById() throws Exception {
        // Assume a book with ID 1 is present in the books list
        mockMvc.perform(get("/api/books/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.id", is(1)))
               .andExpect(jsonPath("$.title", is("Sample Book")))
               .andExpect(jsonPath("$.author", is("John Doe")));
    }

    @Test
    public void testGetNonExistingBook() throws Exception {
        mockMvc.perform(get("/api/books/100"))
               .andExpect(status().isNotFound());
    }

    @Test
    public void testAddBook() throws Exception {
        Book book = new Book();
        book.setId(2L);
        book.setTitle("New Book");
        book.setAuthor("Jane Doe");

        mockMvc.perform(post("/api/books")
                .contentType(MediaType.APPLICATION_JSON)
                .content(asJsonString(book)))
               .andExpect(status().isCreated())
               .andExpect(jsonPath("$.id", is(2)))
               .andExpect(jsonPath("$.title", is("New Book")))
               .andExpect(jsonPath("$.author", is("Jane Doe")));
    }

    // Helper method to convert object to JSON string
    private String asJsonString(Object obj) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.writeValueAsString(obj);
    }
}

==============================================================================================================================
12. Kubernetes


Kubernetes is an open-source container orchestration platform developed by Google. It automates the deployment, scaling, and management 
of containerized applications. With Kubernetes, you can easily manage complex containerized applications,
 ensuring they run reliably and efficiently across clusters of machines. Here are some key concepts and features of Kubernetes:

Containers and Pods:
Kubernetes uses container technology (like Docker) to package applications and their dependencies. Containers are grouped into Pods, 
which are the smallest deployable units in Kubernetes.

Nodes and Clusters:
A Kubernetes cluster is a set of nodes (servers) that run containerized applications. Each node can host multiple Pods. Clusters consist 
of a control plane (master) responsible for managing the cluster and worker nodes that run the applications.

Replication and Scaling:
Kubernetes enables you to scale applications by replicating Pods across nodes. You can define the desired number of replicas for an 
application, and Kubernetes automatically maintains that desired state.

Service Discovery and Load Balancing:
Kubernetes provides internal DNS-based service discovery, allowing Pods to find and communicate with each other by using service names. 
It also automatically load balances traffic across replicas.

Health Checks and Self-Healing:
Kubernetes continually monitors the health of Pods using readiness and liveness probes. If a Pod becomes unhealthy, Kubernetes can 
automatically restart, replace, or reschedule it.

ConfigMaps and Secrets:
Kubernetes provides ConfigMaps to store configuration data and Secrets to store sensitive information like passwords or API keys. 
These can be mounted into Pods as environment variables or files.

Deployments and Rolling Updates:
Deployments are used to manage the rollout and rollback of application updates. Kubernetes supports rolling updates, which ensures 
zero-downtime updates by incrementally updating Pods.

Volumes and Persistent Storage:
Kubernetes supports various types of volumes, allowing containers to store data beyond the lifecycle of the Pod. Persistent Volumes (PVs) 
and Persistent Volume Claims (PVCs) enable data storage that persists across Pod rescheduling.

Namespaces:
Kubernetes allows logical separation of resources using namespaces. This helps organize and isolate applications and resources within the cluster.

Resource Management:
Kubernetes allows you to specify resource requirements (CPU and memory) for Pods, ensuring efficient resource allocation and preventing 
resource contention.

Security and RBAC:
Kubernetes provides Role-Based Access Control (RBAC) to define fine-grained access controls and permissions, enhancing the security of the cluster.

Ingress Controllers:
Ingress controllers allow you to expose services to external traffic by managing external access and load balancing.

Kubernetes has become a standard for container orchestration due to its flexibility, scalability, and robust features. It simplifies 
the management of containerized applications, making it easier to deploy, update, and scale applications in a distributed environment.

==============================================================================================================================
13. Docker

Docker is an open-source platform that automates the deployment, management, and scaling of applications inside containers. Containers 
are lightweight, portable, and self-sufficient units that package an application along with its dependencies, runtime environment, 
and configuration files. Docker allows developers to create, ship, and run applications consistently across various environments, making 
it easier to build, test, and deploy software. Here are some key concepts and features of Docker:

Docker Images:
Docker images are read-only templates that define the application and its environment. They contain everything needed to run an application, 
such as the code, libraries, dependencies, and configurations.

Docker Containers:
Docker containers are instances of Docker images that are running and executing an application. Containers are isolated from each other and 
from the host system, making them secure and portable.

Dockerfile:
A Dockerfile is a text file that contains instructions to build a Docker image. It defines the base image, adds application code, sets environment 
variables, and configures the container.

Docker Registry:
Docker images are stored in repositories on Docker registries. Docker Hub is the default public registry, but you can also use private registries
 to store and manage your images.

Docker Compose:
Docker Compose is a tool that allows you to define and run multi-container applications using a YAML file. It simplifies the process of managing 
multiple containers and their interactions.

Docker Networking:
Docker provides networking capabilities that allow containers to communicate with each other and with the external world. Containers can be 
assigned specific network interfaces or IP addresses.

Docker Volumes:
Docker volumes are used to persist data beyond the lifecycle of containers. They enable data sharing between the host system and containers or 
between multiple containers.

Docker Swarm:
Docker Swarm is Docker's native orchestration tool that allows you to create and manage a cluster of Docker nodes (hosts). It provides features 
for scaling, load balancing, and high availability.

Docker Security:
Docker employs various security measures to isolate containers and protect the host system. Features like namespaces, cgroups, and seccomp 
profiles help ensure container security.

Docker on Cloud Providers:
Docker is widely supported by cloud providers, allowing developers to deploy and manage containerized applications on cloud platforms easily.

Docker has revolutionized the way software is developed, tested, and deployed, providing a standardized and consistent environment for applications. It has become a fundamental tool in modern software development, enabling the adoption of microservices architectures and container-based infrastructure.


Docker and Kubernetes are both popular tools in the world of containerization and cloud-native application development. While they have some overlapping functionalities, they serve different purposes and are often used together in modern application deployment workflows. Let's compare Docker and Kubernetes:

Functionality:

Docker: Docker is a containerization platform that allows developers to create, package, and distribute applications and their dependencies 
as lightweight containers. It provides tools to build, manage, and run containers on various environments, including local development machines,
 testing environments, and production servers.
Kubernetes: Kubernetes is a container orchestration platform that automates the deployment, scaling, and management of containerized applications.
 It provides features for load balancing, self-healing, rolling updates, and high availability across a cluster of nodes.
Scope:

Docker: Docker focuses on creating and managing individual containers, offering tools like Docker Engine to run and manage containers.
Kubernetes: Kubernetes is designed to manage multiple containers and applications deployed across a cluster of nodes. It allows you to define
 complex application architectures using containers and manage them efficiently.
Use Case:

Docker: Docker is suitable for local development, creating lightweight development environments, and building container images for various
 applications and services.
Kubernetes: Kubernetes is ideal for managing production-ready containerized applications at scale. It automates the process of deploying and 
managing containers in large clusters, making it easier to scale, update, and monitor applications in a distributed environment.
Abstraction Level:

Docker: Docker operates at a lower level of abstraction, focusing on individual containers and their images.
Kubernetes: Kubernetes operates at a higher level of abstraction, providing constructs like Pods, Deployments, Services, and ConfigMaps to
 manage complex application deployments and interactions between containers.
Relationship:

Docker and Kubernetes: Kubernetes can use Docker as its container runtime. In other words, Kubernetes can schedule and manage Docker 
containers running on nodes within a cluster. So, Kubernetes can leverage the containerization capabilities of Docker to run applications.
Learning Curve:

Docker: Docker has a relatively lower learning curve, making it easy for developers to get started with containerization.
Kubernetes: Kubernetes has a steeper learning curve due to its more extensive feature set and the need to understand concepts like Pods, 
Deployments, and ReplicaSets.
In summary, Docker and Kubernetes complement each other in the containerization and application deployment process. Docker is used to create
 and manage individual containers and their images, while Kubernetes provides a higher-level abstraction to manage containerized applications 
 in a clustered environment. Together, they form a powerful combination for building, packaging, and scaling modern cloud-native applications.


==============================================================================================================================
14. Mongo

MongoDB is a popular NoSQL database that uses a document-oriented data model, making it easy to store and retrieve complex data structures. A
s a beginner, here are some key concepts and common queries you should learn to work with MongoDB effectively:

Document and Collection:

In MongoDB, data is stored as documents in collections. A document is a set of key-value pairs, similar to a JSON object. 
Collections are groups of related documents.
Basic CRUD Operations:

CRUD stands for Create, Read, Update, and Delete, which are the fundamental operations in any database.
Create: To insert data, use the insertOne() or insertMany() method to add a single document or multiple documents to a collection.
Read: To retrieve data, use the find() method to query documents based on specific conditions or use findOne() to retrieve a single document.
Update: To modify data, use the updateOne() or updateMany() method to update one or multiple documents based on specific criteria.
Delete: To remove data, use the deleteOne() or deleteMany() method to delete one or multiple documents based on specific conditions.
Query Operators:

MongoDB supports a wide range of query operators to perform advanced searches, comparisons, and logical operations. 
Examples include $eq, $ne, $gt, $lt, $in, $and, $or, etc.
Indexing:

Indexes improve query performance by allowing MongoDB to locate and access data more efficiently. Learn about different types of indexes 
(e.g., single-field, compound) and when to use them.
Aggregation Framework:

The aggregation framework provides powerful tools to perform data aggregation operations like grouping, filtering, and computing aggregate values.
 Understand pipeline stages like $match, $group, $project, $sort, etc.
Embedded Documents and Arrays:

MongoDB allows you to nest documents within other documents or use arrays to represent related data. Learn how to work with embedded documents
 and arrays effectively.
Projection:

When querying data, you can use projection to specify which fields to include or exclude in the results. This helps reduce network traffic 
and improve query performance.
Sorting and Pagination:

Learn how to sort query results based on specific fields and how to implement pagination to retrieve data in smaller chunks.
Schema Design:

Understand how to design your data model based on the requirements of your application. Unlike relational databases, MongoDB allows 
flexible schema designs.
Error Handling and Data Validation:

Learn how to handle errors gracefully, validate data before insertion, and use transactions (in case of multi-document operations) to 
maintain data integrity.

Setup MongoDB Connection:
Before performing any operations, make sure you have MongoDB installed and running. Also, include the MongoDB Java driver in your project.
 You can do this by adding the following Maven dependency to your pom.xml:

<dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-sync</artifactId>
    <version>4.3.1</version>
</dependency>

spring.data.mongodb.uri=mongodb://localhost:27017/mydb


public class MongoDBExample {
    public static void main(String[] args) {
        try (MongoClient mongoClient = MongoClients.create("mongodb://localhost:27017")) {
            MongoDatabase database = mongoClient.getDatabase("mydb");
            MongoCollection<Document> collection = database.getCollection("mycollection");

            Document document = new Document("name", "John Doe")
                    .append("age", 30)
                    .append("email", "john@example.com");

            collection.insertOne(document);
			
			FindIterable<Document> documents = collection.find();
            for (Document document : documents) {
                System.out.println(document.toJson());
            }
			
			collection.updateOne(eq("name", "John Doe"), set("age", 31));
			collection.deleteOne(eq("name", "John Doe"));
        }
    }
}

==============================================================================================================================
15. Rabit MQ

RabbitMQ is an open-source message-broker software that enables communication between different systems or microservices in a 
distributed application. It implements the Advanced Message Queuing Protocol (AMQP), allowing decoupling of components, load balancing, 
and asynchronous communication. RabbitMQ facilitates the exchange of messages between producers and consumers, making it a popular choice 
for building scalable and reliable messaging systems. Here are some key concepts and features of RabbitMQ:

Message Broker:
RabbitMQ acts as an intermediary or message broker between producers and consumers. Producers publish messages to RabbitMQ, and c
onsumers receive and process these messages.

Queue:
A queue is a buffer that holds messages until they are consumed. Producers send messages to a queue, and consumers retrieve messages 
from the queue in a first-in-first-out (FIFO) manner.

Exchange:
An exchange is a routing mechanism that receives messages from producers and routes them to specific queues based on the exchange type 
and message attributes.

Binding:
A binding connects an exchange to a queue and defines how messages should be routed to the queue.

Routing Key:
In RabbitMQ, the routing key is used by exchanges to determine the destination queue for a message.

AMQP Protocols:
RabbitMQ uses AMQP, a messaging protocol that ensures interoperability between different messaging systems.

Acknowledgments:
Producers can request acknowledgments (ACK) from consumers to ensure that messages are processed successfully. This helps prevent
 message loss in case of failures.

Exchanges Types:
RabbitMQ supports various exchange types, such as direct, topic, fanout, and headers, providing different routing mechanisms for messages.

Durable Queues and Messages:
RabbitMQ allows queues and messages to be declared as durable, ensuring that they survive server restarts.

Publisher-Subscriber Pattern:
RabbitMQ can be used to implement the publisher-subscriber pattern, where multiple consumers (subscribers) receive messages from a 
single producer (publisher).

Load Balancing:
RabbitMQ can distribute messages to multiple consumers to achieve load balancing and scale the processing of messages.

Dead Letter Exchanges (DLX):
DLX allows handling messages that could not be processed by routing them to a specified exchange, where they can be analyzed and 
retried or handled differently.


RabbitMQ provides client libraries for multiple programming languages, making it accessible for developers using various tech stacks. 
Its flexibility and features make it a powerful messaging solution for building distributed and decoupled systems in modern software architectures.

Prerequisites:
Before you begin, ensure you have RabbitMQ installed and running locally. You can download RabbitMQ from the official
 website (https://www.rabbitmq.com/download.html) and follow the installation instructions for your operating system.
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.14.0</version>
</dependency>


import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

public class RabbitMQProducer {

    private final static String QUEUE_NAME = "my-queue";

    public static void main(String[] argv) throws Exception {
        // Create a connection factory
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        // Create a connection to RabbitMQ server
        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            // Declare a queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);

            // Send a message
            String message = "Hello, RabbitMQ!";
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
            System.out.println("Sent: '" + message + "'");
        }
    }
}


import com.rabbitmq.client.*;

public class RabbitMQConsumer {

    private final static String QUEUE_NAME = "my-queue";

    public static void main(String[] argv) throws Exception {
        // Create a connection factory
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");

        // Create a connection to RabbitMQ server
        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {

            // Declare a queue
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);

            // Create a consumer
            DeliverCallback deliverCallback = (consumerTag, delivery) -> {
                String message = new String(delivery.getBody(), "UTF-8");
                System.out.println("Received: '" + message + "'");
            };

            // Start consuming messages
            channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> {
            });
        }
    }
}

Run the RabbitMQProducer class to send a message to the "my-queue" queue.
Run the RabbitMQConsumer class to receive and process the message from the "my-queue" queue.
==============================================================================================================================
16. OpenShift

OpenShift is a powerful container platform developed by Red Hat, based on Kubernetes. It allows developers to deploy, manage, and scale 
containerized applications. OpenShift provides additional features and tools to streamline the process of building, deploying, 
and running applications on Kubernetes. Here are some key concepts and features of OpenShift:

Container Orchestration:
OpenShift uses Kubernetes as its underlying container orchestration engine. It extends Kubernetes with additional features, making 
it easier to manage and deploy applications.

Developer-Friendly:
OpenShift provides a developer-friendly experience, enabling developers to easily build, test, and deploy applications using familiar
 tools and workflows.

Source-to-Image (S2I):
OpenShift's Source-to-Image (S2I) feature allows developers to build container images directly from source code without needing to 
create Dockerfiles manually.

Build Configurations:
OpenShift Build Configurations define how to build a container image from source code and trigger the build process automatically 
on code changes.

Image Streams:
Image Streams in OpenShift simplify the process of managing container images by allowing you to tag and track images across different environments.

Deployment Configurations:
Deployment Configurations in OpenShift define how applications should be deployed and updated. They support rolling updates, health 
checks, and automated rollbacks.

Routes and Services:
OpenShift provides Routes to expose applications to the external world using DNS names. Services are used to define logical sets of
 Pods and provide load balancing.

Integrated CI/CD Pipelines:
OpenShift integrates with CI/CD tools like Jenkins, allowing you to create automated build and deployment pipelines for applications.

Role-Based Access Control (RBAC):
OpenShift supports Role-Based Access Control, enabling fine-grained access control for users and groups in the cluster.

Monitoring and Logging:
OpenShift offers built-in monitoring and logging capabilities, making it easier to monitor application performance and troubleshoot issues.

Scalability and High Availability:
OpenShift supports horizontal scaling of applications and provides features like clustering and failover for high availability.

Operators:
OpenShift introduces the concept of "Operators," which are application-specific controllers that automate common operational tasks and
 manage complex applications.

OpenShift is widely used in enterprise environments and cloud-native application development. It simplifies the process of deploying and
 managing containerized applications on Kubernetes, providing a robust platform for building scalable and resilient applications.

==============================================================================================================================


